# 用户切换数据隔离方案

**时间**: 2025年11月6日 04:00  
**状态**: ✅ 已实现  

---

## 🎯 问题描述

**关键场景**:
1. 用户A登录 → 数据库切换到 `business_wxid_a.db`
2. 用户A登出
3. **用户B登录 → 如果不切换数据库，用户B的数据会写入用户A的数据库！**

**风险**:
- ❌ 数据污染：用户B的会员/订单混入用户A的数据库
- ❌ 隐私泄露：用户B能看到用户A的数据
- ❌ 数据混乱：无法区分哪些数据属于哪个用户

---

## ✅ 解决方案

### 方案架构

```
┌─────────────────┐
│  用户A登录      │
└────────┬────────┘
         │
         ▼
┌─────────────────────────────────┐
│ LoginEventHandler               │
│ 1. 更新用户信息                 │
│ 2. 检测用户切换 ⚡               │
│ 3. 切换数据库 → business_A.db   │
│ 4. 初始化表结构                 │
└────────┬────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│ VxMain.UserInfoService_Updated  │
│ 1. 检测用户切换 ⚡               │
│ 2. 清空内存数据（会员/订单）    │
│ 3. 更新 UI                      │
│ 4. 重新加载联系人               │
└────────┬────────────────────────┘
         │
         ▼
┌─────────────────┐
│  用户A使用      │
│  数据隔离 ✅     │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  用户A登出      │
└────────┬────────┘
         │
         ▼
┌─────────────────────────────────┐
│ LogoutEventHandler              │
│ 1. 清空用户信息                 │
│ 2. 清空数据库连接 ⚡             │
└────────┬────────────────────────┘
         │
         ▼
┌─────────────────┐
│  用户B登录      │
└────────┬────────┘
         │
         ▼
┌─────────────────────────────────┐
│ LoginEventHandler               │
│ 1. 检测用户切换: null → B ⚡     │
│ 2. 切换数据库 → business_B.db   │
│ 3. 清空内存数据（防污染）       │
└─────────────────────────────────┘
```

---

## 🔧 实现细节

### 1. 修改 `IDatabaseService`

#### 新增方法

```csharp
/// <summary>
/// 切换到指定用户的数据库 (business_{wxid}.db)
/// </summary>
void SwitchDatabase(string wxid);

/// <summary>
/// 获取当前数据库路径
/// </summary>
string GetCurrentDatabasePath();

/// <summary>
/// 获取当前用户的 wxid
/// </summary>
string? GetCurrentWxid();

/// <summary>
/// 清空数据库连接（用户登出时调用）
/// </summary>
void ClearDatabase();
```

---

### 2. 实现 `DatabaseService`

#### 核心字段

```csharp
private string _connectionString = "";  // 🔥 动态连接字符串
private string? _currentWxid;           // 🔥 当前用户 wxid
```

#### SwitchDatabase 实现

```csharp
public void SwitchDatabase(string wxid)
{
    if (string.IsNullOrEmpty(wxid))
    {
        throw new ArgumentException("wxid 不能为空", nameof(wxid));
    }
    
    _currentWxid = wxid;
    
    // 🔥 动态数据库路径：business_{wxid}.db
    var dbPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Data", $"business_{wxid}.db");
    var directory = Path.GetDirectoryName(dbPath);
    if (!string.IsNullOrEmpty(directory))
    {
        Directory.CreateDirectory(directory);
    }
    
    _connectionString = $"Data Source={dbPath};Version=3;Pooling=true;Max Pool Size=10;";
    
    // 初始化新数据库
    InitializeDatabase();
    
    _logService?.Info("DatabaseService", $"✓ 已切换到用户数据库: business_{wxid}.db");
}
```

#### ClearDatabase 实现

```csharp
public void ClearDatabase()
{
    _currentWxid = null;
    _connectionString = "";
    
    _logService?.Info("DatabaseService", "✓ 数据库连接已清空，等待下次登录");
}
```

#### GetConnection 安全检查

```csharp
public SQLiteConnection GetConnection()
{
    if (string.IsNullOrEmpty(_connectionString))
    {
        throw new InvalidOperationException("数据库未初始化，请先调用 SwitchDatabase(wxid)");
    }
    
    // ... 原有逻辑
}
```

---

### 3. 修改 `LoginEventHandler`

#### 检测用户切换并切换数据库

```csharp
public async Task HandleAsync(JsonElement data)
{
    // ... 前面的代码 ...
    
    // 2. 🔥 切换到用户专属数据库 (business_{wxid}.db)
    // 🔥 重要：即使是同一个用户重新登录，也要切换数据库，确保数据隔离
    var currentWxid = _databaseService.GetCurrentWxid();
    if (currentWxid != loginData.Wxid)
    {
        _logService.Info("LoginEventHandler", 
            $"检测到用户切换: {currentWxid ?? "无"} → {loginData.Wxid}，切换数据库...");
        _databaseService.SwitchDatabase(loginData.Wxid);
        _logService.Info("LoginEventHandler", 
            $"✓ 已切换到用户数据库: {_databaseService.GetCurrentDatabasePath()}");
    }
    else
    {
        _logService.Info("LoginEventHandler", 
            $"用户未切换，继续使用当前数据库: {_databaseService.GetCurrentDatabasePath()}");
    }
    
    // ... 后面的代码 ...
}
```

---

### 4. 修改 `LogoutEventHandler`

#### 清空数据库连接

```csharp
public class LogoutEventHandler : IMessageHandler
{
    private readonly ILogService _logService;
    private readonly IUserInfoService _userInfoService;
    private readonly IDatabaseService _databaseService;  // 🔥 新增

    public LogoutEventHandler(
        ILogService logService, 
        IUserInfoService userInfoService,
        IDatabaseService databaseService)      // 🔥 新增
    {
        _logService = logService;
        _userInfoService = userInfoService;
        _databaseService = databaseService;    // 🔥 新增
    }

    public async Task HandleAsync(JsonElement data)
    {
        // ... 前面的代码 ...
        
        // 1. 清空用户信息
        _userInfoService.ClearUserInfo();
        
        // 2. 🔥 清空数据库连接，防止数据污染
        _databaseService.ClearDatabase();
        _logService.Info("LogoutEventHandler", "✓ 数据库连接已清空，防止数据污染");
        
        // ... 后面的代码 ...
    }
}
```

---

### 5. 修改 `VxMain`

#### 检测用户切换并清空内存数据

```csharp
private async void UserInfoService_UserInfoUpdated(object? sender, UserInfoUpdatedEventArgs e)
{
    try
    {
        _logService.Info("VxMain", $"📱 用户信息已更新: {e.UserInfo.Nickname} ({e.UserInfo.Wxid})");

        // 🔥 检测用户切换，清空内存数据
        if (_currentUserInfo != null && !string.IsNullOrEmpty(_currentUserInfo.Wxid))
        {
            if (_currentUserInfo.Wxid != e.UserInfo.Wxid)
            {
                _logService.Warning("VxMain", 
                    $"⚠️ 检测到用户切换: {_currentUserInfo.Wxid} → {e.UserInfo.Wxid}，清空内存数据...");
                
                // 清空所有列表数据，防止数据污染
                if (InvokeRequired)
                {
                    Invoke(new Action(() =>
                    {
                        _contactsBindingList.Clear();
                        _membersBindingList.Clear();
                        _ordersBindingList.Clear();
                        _currentBoundContact = null;
                        txtCurrentContact.Text = "未绑定";
                        txtCurrentContact.FillColor = Color.White;
                        txtCurrentContact.RectColor = Color.Silver;
                    }));
                }
                else
                {
                    _contactsBindingList.Clear();
                    _membersBindingList.Clear();
                    _ordersBindingList.Clear();
                    _currentBoundContact = null;
                    txtCurrentContact.Text = "未绑定";
                    txtCurrentContact.FillColor = Color.White;
                    txtCurrentContact.RectColor = Color.Silver;
                }
                
                _logService.Info("VxMain", "✓ 内存数据已清空");
            }
        }
        
        // 更新当前用户信息
        _currentUserInfo = e.UserInfo;
        
        // ... 后面的UI更新代码 ...
    }
    catch (Exception ex)
    {
        _logService.Error("VxMain", "处理用户信息更新失败", ex);
    }
}
```

---

## 📊 数据流程示例

### 场景1: 用户A登录

```
1. 用户A登录
   ├─ LoginEventHandler
   │  ├─ 检测: currentWxid = null, loginWxid = "wxid_a"
   │  ├─ 切换数据库: business_wxid_a.db
   │  └─ 初始化表: Members, Orders, contacts_wxid_a
   │
   ├─ VxMain.UserInfoService_Updated
   │  ├─ _currentUserInfo = null（首次登录）
   │  └─ 更新 UI
   │
   └─ 结果
      ├─ Database: business_wxid_a.db
      ├─ Memory: 空（首次登录）
      └─ UI: 显示用户A信息
```

### 场景2: 用户A → 用户B（切换）

```
1. 用户A登出
   ├─ LogoutEventHandler
   │  ├─ 清空用户信息
   │  └─ 清空数据库: currentWxid = null, connectionString = ""
   │
   └─ VxMain.UserInfoService_Updated
      └─ UI: 显示"未连接"

2. 用户B登录
   ├─ LoginEventHandler
   │  ├─ 检测: currentWxid = null, loginWxid = "wxid_b" ⚠️ 切换！
   │  ├─ 切换数据库: business_wxid_b.db
   │  └─ 初始化表: Members, Orders, contacts_wxid_b
   │
   ├─ VxMain.UserInfoService_Updated
   │  ├─ 检测: _currentUserInfo.Wxid = "wxid_a", e.UserInfo.Wxid = "wxid_b" ⚠️ 切换！
   │  ├─ 清空内存: _contactsBindingList, _membersBindingList, _ordersBindingList
   │  └─ 更新 UI
   │
   └─ 结果
      ├─ Database: business_wxid_b.db （用户B的数据库）
      ├─ Memory: 空（已清空用户A的数据）
      └─ UI: 显示用户B信息
```

### 场景3: 用户A重新登录（未登出）

```
1. 用户A重新登录（如网络重连）
   ├─ LoginEventHandler
   │  ├─ 检测: currentWxid = "wxid_a", loginWxid = "wxid_a" ✅ 相同
   │  └─ 跳过切换数据库
   │
   ├─ VxMain.UserInfoService_Updated
   │  ├─ 检测: _currentUserInfo.Wxid = "wxid_a", e.UserInfo.Wxid = "wxid_a" ✅ 相同
   │  └─ 跳过清空内存
   │
   └─ 结果
      ├─ Database: business_wxid_a.db （保持不变）
      ├─ Memory: 保持（会员/订单数据保留）
      └─ UI: 更新用户A信息
```

---

## ✅ 验收标准

### 测试1: 不同用户数据隔离

1. 启动 BaiShengVx3Plus
2. 登录用户A（wxid_a）
3. 添加会员"张三"到用户A
4. 登出用户A
5. 登录用户B（wxid_b）
6. 查看会员列表

**预期结果**:
- ✅ 会员列表为空（看不到用户A的"张三"）
- ✅ 日志显示："检测到用户切换: wxid_a → wxid_b，切换数据库..."
- ✅ 数据库文件存在：`business_wxid_a.db` 和 `business_wxid_b.db`

### 测试2: 登出后数据隔离

1. 登录用户A
2. 添加会员"张三"
3. 登出
4. **不关闭程序**，登录用户B
5. 添加会员"李四"

**预期结果**:
- ✅ 用户A的数据库（business_wxid_a.db）包含"张三"
- ✅ 用户B的数据库（business_wxid_b.db）包含"李四"
- ✅ 两个用户的数据完全隔离

### 测试3: 重连后数据保持

1. 登录用户A
2. 添加会员"张三"
3. 断开微信（不登出）
4. 重新连接微信（用户A）

**预期结果**:
- ✅ 会员列表仍然显示"张三"
- ✅ 日志显示："用户未切换，继续使用当前数据库"
- ✅ 数据保持不变

---

## 🎯 核心保护机制

### 三重保护

1. **数据库层保护** (`DatabaseService`)
   - 登出时清空连接字符串
   - 登录时检测用户切换
   - 动态创建用户专属数据库

2. **消息层保护** (`LoginEventHandler`, `LogoutEventHandler`)
   - 登录时切换数据库
   - 登出时清空数据库连接

3. **UI层保护** (`VxMain`)
   - 检测用户切换
   - 清空内存数据（BindingList）
   - 重置UI状态

---

## ⚠️ 注意事项

### 1. 性能影响

- 切换数据库时需要重新建立连接（~10ms）
- 首次登录时需要创建数据库和表（~50ms）
- **影响可忽略**

### 2. 数据迁移

如果之前使用固定的 `business.db`，需要手动迁移数据到用户专属数据库。

**迁移步骤**:
```sql
-- 1. 备份旧数据
cp Data/business.db Data/business_backup.db

-- 2. 登录用户后，手动从 backup 导入数据（如需要）
```

### 3. 多开场景

如果同时运行多个 `BaiShengVx3Plus` 实例，每个实例都有独立的内存数据，不会冲突。
但数据库文件是共享的（SQLite WAL 模式支持并发读写）。

---

## 📚 相关文档

- **紧急修复清单**: `BaiShengVx3Plus/0-资料/20251106-紧急修复清单.md`
- **核心功能修复进度**: `BaiShengVx3Plus/0-资料/20251106-核心功能修复进度.md`

---

**时间**: 2025年11月6日 04:00  
**状态**: ✅ 已实现  
**测试**: ⏸️ 待用户测试

