# 浏览器管理 - 监控任务方案

## 问题描述

之前的方案在主程序重启时，即使老浏览器还在运行并尝试重连，主程序仍会启动新的浏览器进程，导致：
1. 多个浏览器同时运行
2. 互相抢占连接，形成死循环
3. 日志显示浏览器疯狂重连（端口从 54047→54098）

## 根本原因

**依赖时机不对**：在飞单开关打开时立即调用 `StartBrowser`，此时老浏览器可能还在重连中，检查通过后又启动了新浏览器。

## 新方案：监控任务 + 被动启动

### 核心思想

1. **飞单开关打开** → 只标记配置需要启动（添加到 `_enabledConfigs`）
2. **后台监控任务**（每3秒）持续检查：
   - 配置需要启动吗？（在 `_enabledConfigs` 中）
   - 配置已连接吗？（在 `_browsers` 中）
   - 如果**需要启动 且 未连接**，才真正启动浏览器
3. **自动恢复**：无论是主程序重启、浏览器崩溃，都能自动恢复

### 工作流程

#### 1. 主程序启动

```
VxMain 启动
  ↓
启动 Socket 服务器（端口 19527）
  ↓
启动后台监控任务（每3秒，首次延迟5秒）
  ↓
加载配置
  ↓
如果飞单开关=true，调用 StartBrowser(configId)
```

#### 2. StartBrowser 被调用（新逻辑）

```csharp
public async Task<bool> StartBrowser(int configId)
{
    lock (_lock)
    {
        // 1. 标记配置需要启动
        _enabledConfigs.Add(configId);
        
        // 2. 检查是否已连接
        if (_browsers.ContainsKey(configId))
        {
            return true; // 已连接，直接返回
        }
    }
    
    // 3. 未连接，立即返回，让监控任务处理
    await Task.Delay(100);
    return true;
}
```

**关键点**：
- **不等待**，不阻塞主线程
- **不启动**浏览器，只标记需要启动
- 监控任务会自动处理

#### 3. 老浏览器重连（如果存在）

```
老浏览器检测到 Socket 断开
  ↓
1秒后自动重连（BsBrowserClient 的逻辑）
  ↓
连接成功，发送握手消息
  ↓
VxMain.OnBrowserConnected 被调用
  ↓
自动创建 BrowserClient 并添加到 _browsers 字典
```

**关键点**：
- 老浏览器重连是**自动的**，无需主程序等待
- `OnBrowserConnected` 自动处理重连，无论主程序是否重启

#### 4. 监控任务每3秒检查

```csharp
private void MonitorBrowsers(object? state)
{
    foreach (var configId in _enabledConfigs)
    {
        lock (_lock)
        {
            // 检查是否已连接
            if (_browsers.ContainsKey(configId))
            {
                continue; // 已连接，跳过
            }
        }
        
        // 未连接，启动新浏览器
        _ = Task.Run(async () =>
        {
            await StartBrowserInternal(configId);
        });
    }
}
```

**关键点**：
- 首次执行延迟**5秒**，给老浏览器重连的时间
- 每次检查前都判断 `_browsers.ContainsKey(configId)`
- 如果已连接，就不启动

#### 5. 时间线示例（主程序重启场景）

| 时间 | 事件 | 说明 |
|------|------|------|
| 0s | 主程序启动 | Socket 服务器启动，监控任务启动（5秒后首次执行） |
| 0.1s | 飞单开关=true | 调用 `StartBrowser(1)`，标记配置1需要启动 |
| 0.2s | `StartBrowser` 返回 | 检查 `_browsers` 为空，立即返回，不等待 |
| 1s | 老浏览器重连 | 检测到断线，1秒后重连成功 |
| 1.1s | `OnBrowserConnected` | 自动创建 `BrowserClient`，添加到 `_browsers[1]` |
| 5s | 监控任务首次执行 | 检查配置1，发现已在 `_browsers` 中，**不启动新浏览器** |
| 8s | 监控任务第2次执行 | 检查配置1，仍在 `_browsers` 中，**不启动** |

**结果**：✅ 只有1个浏览器，老浏览器成功重连

#### 6. 时间线示例（老浏览器未运行）

| 时间 | 事件 | 说明 |
|------|------|------|
| 0s | 主程序启动 | Socket 服务器启动，监控任务启动（5秒后首次执行） |
| 0.1s | 飞单开关=true | 调用 `StartBrowser(1)`，标记配置1需要启动 |
| 0.2s | `StartBrowser` 返回 | 检查 `_browsers` 为空，立即返回 |
| 5s | 监控任务首次执行 | 检查配置1，**不在 `_browsers` 中**，启动新浏览器 |
| 5.1s | 新浏览器启动 | 创建进程，2秒后连接 Socket |
| 7.1s | `OnBrowserConnected` | 新浏览器连接成功，添加到 `_browsers[1]` |
| 8s | 监控任务第2次执行 | 检查配置1，已在 `_browsers` 中，**不重复启动** |

**结果**：✅ 只有1个浏览器，新浏览器成功启动

### 代码变更

#### 1. AutoBetService.cs

```csharp
// 新增字段
private System.Threading.Timer? _monitorTimer;
private readonly HashSet<int> _enabledConfigs = new();
private readonly object _lock = new object();

// 构造函数中启动监控任务
_monitorTimer = new System.Threading.Timer(
    MonitorBrowsers, 
    null, 
    TimeSpan.FromSeconds(5),  // 首次延迟5秒
    TimeSpan.FromSeconds(3)   // 每3秒执行一次
);

// StartBrowser：只标记，不启动
public async Task<bool> StartBrowser(int configId)
{
    lock (_lock)
    {
        _enabledConfigs.Add(configId);
        if (_browsers.ContainsKey(configId))
        {
            return true; // 已连接
        }
    }
    await Task.Delay(100);
    return true; // 让监控任务处理
}

// 监控任务：按需启动
private void MonitorBrowsers(object? state)
{
    foreach (var configId in _enabledConfigs)
    {
        lock (_lock)
        {
            if (_browsers.ContainsKey(configId))
            {
                continue; // 已连接，跳过
            }
        }
        
        // 异步启动
        _ = Task.Run(async () =>
        {
            await StartBrowserInternal(configId);
        });
    }
}

// 实际启动逻辑
private async Task<bool> StartBrowserInternal(int configId)
{
    // 再次检查（避免并发）
    lock (_lock)
    {
        if (_browsers.ContainsKey(configId))
        {
            return true;
        }
    }
    
    // 启动浏览器进程...
}

// StopBrowser：从启用列表移除
public void StopBrowser(int configId)
{
    lock (_lock)
    {
        _enabledConfigs.Remove(configId);
    }
    // 停止浏览器...
}
```

#### 2. OnBrowserConnected（无需修改）

```csharp
private void OnBrowserConnected(int configId, TcpClient client)
{
    lock (_lock)
    {
        if (_browsers.TryGetValue(configId, out var existing))
        {
            existing.AttachConnection(client); // 更新连接
        }
        else
        {
            // 主程序重启场景：自动创建 BrowserClient
            var browserClient = new BrowserClient(configId);
            browserClient.AttachConnection(client);
            _browsers[configId] = browserClient;
        }
    }
}
```

### 优势

1. **解耦**：飞单开关打开 ≠ 立即启动浏览器
2. **智能**：自动检测连接状态，按需启动
3. **容错**：无论主程序重启、浏览器崩溃，都能自动恢复
4. **简单**：依赖连接状态（`_browsers` 字典），不依赖窗口标题
5. **高效**：不阻塞主线程，异步处理

### 测试场景

| 场景 | 预期结果 |
|------|---------|
| 首次启动，飞单开=true | 5秒后启动新浏览器 |
| 主程序重启，老浏览器在运行 | 老浏览器重连，不启动新的 |
| 主程序重启，老浏览器已关闭 | 5秒后启动新浏览器 |
| 浏览器崩溃 | 3秒内自动重启 |
| 手动关闭飞单开关 | 停止浏览器，从启用列表移除 |

## 总结

**核心原则**：**不要猜，只检查连接状态**

- 如果 `_browsers` 中有这个配置 → 已连接，不启动
- 如果 `_browsers` 中没有 → 未连接，启动新的
- 监控任务持续检查，自动恢复

这样就彻底解决了"明明握手成功了，还要打开浏览器"的问题！

