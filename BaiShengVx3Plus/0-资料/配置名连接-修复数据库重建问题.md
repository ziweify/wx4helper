# 配置名连接 - 修复数据库重建问题

## 📋 问题描述

用户反馈：**数据库删除后，重新打开程序，关闭飞单，启动飞单，弹出的浏览器，输入账号密码后，连接又不对了。在高级设置中进行投注命令，又出现未连接了。**

---

## 🔍 问题根源

### 原来的设计缺陷

```
数据库删除前：
  - 默认配置：ConfigName="默认配置", Id=5
  - 浏览器启动：--config-id 5 --config-name "默认配置"
  - 浏览器连接：发送 configId=5
  - VxMain: OnBrowserConnected(int configId=5)
  - 查找配置：GetConfig(5) ✅ 找到
  - 连接成功 ✅

数据库删除后：
  - 数据库重建，默认配置：ConfigName="默认配置", Id=1 ← ID变了！
  - 浏览器仍在运行：configId=5（旧的）, configName="默认配置"
  - 浏览器重连：发送 configId=5
  - VxMain: OnBrowserConnected(int configId=5)
  - 查找配置：GetConfig(5) ❌ 找不到（现在是Id=1）
  - ❌ 连接被拒绝！
```

### 核心问题

**使用配置ID作为唯一标识**：
- 配置ID是数据库自增主键
- 数据库删除后，ID会从1重新开始
- 浏览器进程可能还在运行，使用旧的ID
- ID不匹配 → 连接失败

**正确的设计**：
- 配置名是固定的（如"默认配置"）
- 数据库删除后，配置名不变
- 浏览器应该用配置名来匹配配置

---

## ✅ 解决方案

### 修改1：AutoBetSocketServer - 传递配置名

**文件：`BaiShengVx3Plus/Services/AutoBet/AutoBetSocketServer.cs`**

```csharp
// ❌ 旧代码
private readonly Action<int, TcpClient> _onBrowserConnected;

public AutoBetSocketServer(
    ILogService log, 
    Action<int, TcpClient> onBrowserConnected,  // ← 传递 configId
    ...)
{
    _onBrowserConnected = onBrowserConnected;
}

// 在握手处理中
configId = handshake["configId"]?.ToObject<int>() ?? -1;
var configName = handshake["configName"]?.ToString() ?? "";  // 解析了但没用

// 通知 AutoBetService
_onBrowserConnected(configId, client);  // ← 只传递了 configId


// ✅ 新代码
private readonly Action<string, TcpClient> _onBrowserConnected;  // 🔥 改为 string configName

public AutoBetSocketServer(
    ILogService log, 
    Action<string, TcpClient> onBrowserConnected,  // 🔥 改为 string configName
    ...)
{
    _onBrowserConnected = onBrowserConnected;
}

// 在握手处理中
configId = handshake["configId"]?.ToObject<int>() ?? -1;
var configName = handshake["configName"]?.ToString() ?? "";

// 🔥 配置名是必须的，用于匹配配置
if (string.IsNullOrEmpty(configName))
{
    _log.Warning("AutoBetServer", "握手失败：配置名为空");
    return;
}

// 通知 AutoBetService
_onBrowserConnected(configName, client);  // 🔥 传递配置名，而不是配置ID
```

### 修改2：AutoBetService - 用配置名查找配置

**文件：`BaiShengVx3Plus/Services/AutoBet/AutoBetService.cs`**

```csharp
// ❌ 旧代码
private void OnBrowserConnected(int configId, TcpClient client)
{
    _log.Info("AutoBet", $"🔗 浏览器已通过 Socket 连接，配置ID: {configId}");
    
    // 根据配置ID查找配置
    var config = GetConfig(configId);
    if (config == null)
    {
        _log.Error("AutoBet", $"❌ 配置不存在: {configId}，拒绝连接");
        return;  // ← 数据库重建后，ID不匹配，拒绝连接！
    }
    
    // ...
}


// ✅ 新代码
private void OnBrowserConnected(string configName, TcpClient client)  // 🔥 改为 string configName
{
    _log.Info("AutoBet", $"🔗 浏览器已通过 Socket 连接，配置名: {configName}");
    
    // 🔥 根据配置名查找配置（而不是配置ID）
    BetConfig? config;
    lock (_lock)
    {
        config = _configs.FirstOrDefault(c => c.ConfigName == configName);
    }
    
    if (config == null)
    {
        _log.Error("AutoBet", $"❌ 配置不存在: {configName}，拒绝连接");
        return;
    }
    
    int configId = config.Id;  // ← 获取当前的配置ID
    _log.Info("AutoBet", $"✅ 配置信息: {config.ConfigName} (Id={configId}, {config.Platform})");
    _log.Info("AutoBet", $"   说明：配置名固定，但数据库重建后配置ID可能变化");
    
    // 创建或更新 BrowserClient（使用当前的配置ID）
    if (_browsers.TryGetValue(configId, out var existingBrowser))
    {
        existingBrowser.AttachConnection(client);
    }
    else
    {
        _log.Info("AutoBet", $"📌 _browsers 字典中无此配置，自动创建 BrowserClient");
        _log.Info("AutoBet", $"   场景：主程序重启、数据库重建、或浏览器先于主程序启动");
        
        var browserClient = new BrowserClient(configId);  // ← 使用当前的配置ID
        browserClient.AttachConnection(client);
        
        lock (_lock)
        {
            _browsers[configId] = browserClient;
        }
    }
    
    // ...
}
```

---

## 🎯 修复后的流程

### 数据库删除后重新连接

```
数据库删除前：
  - 默认配置：ConfigName="默认配置", Id=5
  - 浏览器启动：--config-id 5 --config-name "默认配置"
  - 浏览器运行中...

数据库删除：
  - 用户删除数据库
  - 重新打开主程序
  - EnsureDefaultConfig 创建新的默认配置
  - 新配置：ConfigName="默认配置", Id=1 ← ID变了，但名字不变

浏览器重连：
  1. 浏览器发送握手：
     └─ { "configId": 5, "configName": "默认配置" }
  
  2. AutoBetSocketServer.HandleClientAsync:
     ├─ 解析 configId=5 (旧的，忽略)
     ├─ 解析 configName="默认配置" (固定的，使用这个)
     └─ 调用：_onBrowserConnected("默认配置", client)  ← 传递配置名
  
  3. AutoBetService.OnBrowserConnected:
     ├─ 收到 configName="默认配置"
     ├─ 根据配置名查找：config = _configs.FirstOrDefault(c => c.ConfigName == "默认配置")
     ├─ ✅ 找到配置！config.Id = 1 (新的ID)
     ├─ 创建 BrowserClient(configId=1)  ← 使用新的ID
     └─ _browsers[1] = browserClient
  
  4. 连接成功 ✅
     └─ 配置名匹配成功，即使配置ID变化了也能正常连接
```

---

## 📊 对比表

| 场景 | 旧逻辑（用ID匹配） | 新逻辑（用名字匹配） |
|------|-------------------|---------------------|
| **正常运行** | ✅ 正常 | ✅ 正常 |
| **主程序重启** | ✅ 正常 | ✅ 正常 |
| **数据库删除后** | ❌ ID不匹配，拒绝连接 | ✅ 名字匹配，连接成功 |
| **多配置场景** | ⚠️ 需要配置名唯一 | ✅ 配置名唯一，完全支持 |

---

## 📝 修改文件清单

### 修改文件

1. **`BaiShengVx3Plus/Services/AutoBet/AutoBetSocketServer.cs`**
   - 修改回调签名：`Action<int, TcpClient>` → `Action<string, TcpClient>`
   - 握手处理：传递 `configName` 而不是 `configId`
   - 增强校验：配置名不能为空

2. **`BaiShengVx3Plus/Services/AutoBet/AutoBetService.cs`**
   - 修改方法签名：`OnBrowserConnected(int configId, ...)` → `OnBrowserConnected(string configName, ...)`
   - 查找配置：`GetConfig(configId)` → `_configs.FirstOrDefault(c => c.ConfigName == configName)`
   - 增强日志：说明配置名固定，ID可能变化

---

## ✅ 修复效果

### 修复前的问题：
❌ 数据库删除后，配置ID重新从1开始  
❌ 浏览器使用旧的配置ID  
❌ `GetConfig(旧ID)` 返回 null  
❌ 连接被拒绝  

### 修复后：
✅ 浏览器发送配置名（固定不变）  
✅ VxMain 根据配置名查找配置  
✅ 找到配置，获取当前的配置ID  
✅ 使用当前的配置ID创建 BrowserClient  
✅ 连接成功，即使配置ID变化了也能正常工作  

---

## 🎯 设计理念

### 配置名 vs 配置ID

**配置名（ConfigName）**：
- ✅ 用户定义，具有业务含义
- ✅ 固定不变（除非用户修改）
- ✅ 适合作为外部标识（如浏览器连接）
- ✅ 数据库重建后不变

**配置ID（Id）**：
- ⚠️ 数据库自增主键
- ⚠️ 数据库删除后重新从1开始
- ⚠️ 内部使用，外部不应依赖
- ✅ 适合作为字典 key（_browsers[configId]）

### 最佳实践

```
外部连接 → 使用配置名
  └─ 浏览器 → VxMain: "我是'默认配置'"
       └─ VxMain: 查找配置名="默认配置" 的配置
            └─ 找到 config (Id=1 或 Id=5，无所谓)
                 └─ 使用 config.Id 创建 BrowserClient

内部管理 → 使用配置ID
  └─ _browsers[config.Id] = browserClient
       └─ 高效的字典查找
```

**现在即使数据库删除重建，浏览器也能通过配置名正确连接！** 🎯

