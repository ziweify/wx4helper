# é€šä¿¡æœºåˆ¶ä¼˜åŒ–è®¾è®¡ - æ”¯æŒå¤šæµè§ˆå™¨å®ä¾‹

## ğŸ¯ éœ€æ±‚åˆ†æ

### å½“å‰éœ€æ±‚
- VxMain åŒæ—¶è¿æ¥**å¤šä¸ª**æµè§ˆå™¨æ¨¡å—
- å‘**ä¸åŒ**çš„æµè§ˆå™¨å‘é€**ä¸åŒ**çš„è®¢å•
- æ¥æ”¶**æ¯ä¸ª**æµè§ˆå™¨çš„è¿”å›ç»“æœ
- æ˜“äºæ‰©å±•ã€æ˜“äºç®¡ç†

### é—®é¢˜åˆ†æ
Named Pipes çš„å±€é™æ€§ï¼š
1. âŒ ä¸€å¯¹ä¸€è¿æ¥ï¼Œä¸é€‚åˆå¤šå®ä¾‹
2. âŒ éœ€è¦ä¸ºæ¯ä¸ªå®ä¾‹åˆ›å»ºä¸åŒç®¡é“å
3. âŒ ç®¡ç†å¤æ‚åº¦é«˜
4. âŒ ä¸æ”¯æŒå¹¿æ’­å’Œè®¢é˜…

---

## âœ… ä¼˜åŒ–æ–¹æ¡ˆï¼šWebSocket é€šä¿¡

### æ–¹æ¡ˆå¯¹æ¯”

| æ–¹æ¡ˆ | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‚ç”¨åœºæ™¯ |
|------|------|------|---------|
| **Named Pipes** | æ€§èƒ½å¥½ã€æœ¬åœ°é€šä¿¡ | ä¸€å¯¹ä¸€ã€ç®¡ç†å¤æ‚ | âŒ ä¸é€‚åˆå¤šå®ä¾‹ |
| **WebSocket** | æ”¯æŒå¤šè¿æ¥ã€åŒå‘é€šä¿¡ã€æ˜“ç®¡ç† | ç¨å¾®å¤æ‚ | âœ… **æ¨èï¼šå¤šå®ä¾‹åœºæ™¯** |
| **gRPC** | é«˜æ€§èƒ½ã€ç±»å‹å®‰å…¨ | é…ç½®å¤æ‚ã€å­¦ä¹ æˆæœ¬é«˜ | å¤§è§„æ¨¡å¾®æœåŠ¡ |
| **HTTP REST** | ç®€å•ã€é€šç”¨ | å•å‘é€šä¿¡ã€ä¸æ”¯æŒæ¨é€ | ç®€å•è¯·æ±‚å“åº” |

### é€‰æ‹© WebSocket çš„ç†ç”±

1. âœ… **ä¸€å¯¹å¤šè¿æ¥**ï¼šä¸€ä¸ª Server å¯ä»¥ç®¡ç†å¤šä¸ª Client
2. âœ… **åŒå‘é€šä¿¡**ï¼šæ”¯æŒå‘½ä»¤ä¸‹å‘å’Œäº‹ä»¶æ¨é€
3. âœ… **æ˜“äºæ‰©å±•**ï¼šæ·»åŠ æ–°å®ä¾‹åªéœ€å»ºç«‹æ–°è¿æ¥
4. âœ… **çµæ´»è·¯ç”±**ï¼šå¯ä»¥æ ¹æ®å®ä¾‹IDç²¾å‡†æŠ•é€’æ¶ˆæ¯
5. âœ… **æˆç†Ÿç”Ÿæ€**ï¼šåº“å¤šã€æ–‡æ¡£å…¨ã€æ˜“è°ƒè¯•
6. âœ… **æ”¯æŒè®¢é˜…**ï¼šå¯ä»¥å®ç°å‘å¸ƒ-è®¢é˜…æ¨¡å¼

---

## ğŸ—ï¸ æ–°æ¶æ„è®¾è®¡

### æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    VxMain (ä¸»ç¨‹åº)                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚          WebSocket Server (Port: 8765)                    â”‚  â”‚
â”‚  â”‚   â€¢ ç›‘å¬æ‰€æœ‰æµè§ˆå™¨è¿æ¥                                      â”‚  â”‚
â”‚  â”‚   â€¢ ç®¡ç†è¿æ¥æ±                                              â”‚  â”‚
â”‚  â”‚   â€¢ æ¶ˆæ¯è·¯ç”±                                               â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                  â”‚                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚       ConnectionManager (è¿æ¥ç®¡ç†å™¨)                       â”‚  â”‚
â”‚  â”‚   â€¢ Connections: Dictionary<InstanceId, WebSocket>        â”‚  â”‚
â”‚  â”‚   â€¢ SendToInstance(instanceId, message)                   â”‚  â”‚
â”‚  â”‚   â€¢ Broadcast(message)                                    â”‚  â”‚
â”‚  â”‚   â€¢ GetConnections() â†’ List<BrowserInstance>              â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                  â”‚                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚       AutoBetDispatcher (è®¢å•åˆ†å‘å™¨)                       â”‚  â”‚
â”‚  â”‚   â€¢ åˆ†é…è®¢å•åˆ°æŒ‡å®šæµè§ˆå™¨                                    â”‚  â”‚
â”‚  â”‚   â€¢ è´Ÿè½½å‡è¡¡                                               â”‚  â”‚
â”‚  â”‚   â€¢ ç»“æœèšåˆ                                               â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â”‚ WebSocket (ws://localhost:8765)
                  â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚             â”‚             â”‚             â”‚
â”Œâ”€â”€â”€â–¼â”€â”€â”€â”     â”Œâ”€â”€â–¼â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â–¼â”€â”€â”€â”    â”Œâ”€â”€â”€â–¼â”€â”€â”€â”
â”‚Browserâ”‚     â”‚Browserâ”‚    â”‚Browserâ”‚    â”‚Browserâ”‚
â”‚   1   â”‚     â”‚   2   â”‚    â”‚   3   â”‚    â”‚  ...  â”‚
â”‚äº‘é¡¶28 â”‚     â”‚ç‚³ç‹—28 â”‚    â”‚å¿«ä¹8  â”‚    â”‚  ...  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”˜
  Client        Client       Client       Client
  ç‹¬ç«‹è¿›ç¨‹       ç‹¬ç«‹è¿›ç¨‹       ç‹¬ç«‹è¿›ç¨‹       ç‹¬ç«‹è¿›ç¨‹
```

---

## ğŸ“¦ æ ¸å¿ƒç»„ä»¶å®ç°

### 1. WebSocket Serverï¼ˆVxMain ç«¯ï¼‰

```csharp
using System.Net.WebSockets;
using System.Net;
using System.Text;
using Newtonsoft.Json;

namespace BaiShengVx3Plus.Services.AutoBet
{
    /// <summary>
    /// WebSocket æœåŠ¡å™¨ - ç®¡ç†æ‰€æœ‰æµè§ˆå™¨è¿æ¥
    /// </summary>
    public class BrowserWebSocketServer
    {
        private readonly HttpListener _httpListener;
        private readonly ConnectionManager _connectionManager;
        private readonly ILogService _logService;
        private CancellationTokenSource _cts;
        
        public BrowserWebSocketServer(int port, ILogService logService)
        {
            _httpListener = new HttpListener();
            _httpListener.Prefixes.Add($"http://localhost:{port}/");
            _connectionManager = new ConnectionManager(logService);
            _logService = logService;
        }
        
        /// <summary>
        /// å¯åŠ¨æœåŠ¡å™¨
        /// </summary>
        public async Task StartAsync()
        {
            _cts = new CancellationTokenSource();
            _httpListener.Start();
            _logService.Info("WebSocketServer", "ğŸš€ WebSocket æœåŠ¡å™¨å·²å¯åŠ¨");
            
            while (!_cts.Token.IsCancellationRequested)
            {
                try
                {
                    var context = await _httpListener.GetContextAsync();
                    
                    if (context.Request.IsWebSocketRequest)
                    {
                        // ğŸ”¥ æ¥å— WebSocket è¿æ¥
                        var wsContext = await context.AcceptWebSocketAsync(null);
                        _ = HandleConnectionAsync(wsContext.WebSocket);
                    }
                    else
                    {
                        context.Response.StatusCode = 400;
                        context.Response.Close();
                    }
                }
                catch (Exception ex)
                {
                    _logService.Error("WebSocketServer", "å¤„ç†è¿æ¥å¤±è´¥", ex);
                }
            }
        }
        
        /// <summary>
        /// å¤„ç†å•ä¸ªæµè§ˆå™¨è¿æ¥
        /// </summary>
        private async Task HandleConnectionAsync(WebSocket webSocket)
        {
            string? instanceId = null;
            
            try
            {
                var buffer = new byte[4096];
                
                while (webSocket.State == WebSocketState.Open)
                {
                    var result = await webSocket.ReceiveAsync(
                        new ArraySegment<byte>(buffer), 
                        CancellationToken.None);
                    
                    if (result.MessageType == WebSocketMessageType.Close)
                    {
                        await webSocket.CloseAsync(
                            WebSocketCloseStatus.NormalClosure, 
                            "Closing", 
                            CancellationToken.None);
                        break;
                    }
                    
                    if (result.MessageType == WebSocketMessageType.Text)
                    {
                        var messageJson = Encoding.UTF8.GetString(buffer, 0, result.Count);
                        var message = JsonConvert.DeserializeObject<WebSocketMessage>(messageJson);
                        
                        // ğŸ”¥ å¤„ç†ä¸åŒç±»å‹çš„æ¶ˆæ¯
                        await HandleMessageAsync(webSocket, message, ref instanceId);
                    }
                }
            }
            catch (Exception ex)
            {
                _logService.Error("WebSocketServer", $"è¿æ¥å¼‚å¸¸: {instanceId}", ex);
            }
            finally
            {
                // ğŸ”¥ ç§»é™¤è¿æ¥
                if (instanceId != null)
                {
                    _connectionManager.RemoveConnection(instanceId);
                    _logService.Info("WebSocketServer", $"âŒ æµè§ˆå™¨æ–­å¼€: {instanceId}");
                }
            }
        }
        
        /// <summary>
        /// å¤„ç†æ¶ˆæ¯
        /// </summary>
        private async Task HandleMessageAsync(
            WebSocket webSocket, 
            WebSocketMessage message, 
            ref string? instanceId)
        {
            switch (message.Type)
            {
                case "Register":
                    // ğŸ”¥ æµè§ˆå™¨æ³¨å†Œ
                    instanceId = message.Data["InstanceId"]?.ToString();
                    if (instanceId != null)
                    {
                        _connectionManager.AddConnection(instanceId, webSocket, message.Data);
                        _logService.Info("WebSocketServer", 
                            $"âœ… æµè§ˆå™¨å·²è¿æ¥: {instanceId} - {message.Data["Platform"]}");
                        
                        // å›å¤æ³¨å†ŒæˆåŠŸ
                        await SendAsync(webSocket, new WebSocketMessage
                        {
                            Type = "RegisterSuccess",
                            Data = new { InstanceId = instanceId }
                        });
                    }
                    break;
                    
                case "Event":
                    // ğŸ”¥ æµè§ˆå™¨äº‹ä»¶ï¼ˆçŠ¶æ€å˜åŒ–ã€ä½™é¢æ›´æ–°ç­‰ï¼‰
                    OnBrowserEvent?.Invoke(this, new BrowserEventArgs
                    {
                        InstanceId = instanceId,
                        EventType = message.Data["EventType"]?.ToString(),
                        EventData = message.Data["EventData"]
                    });
                    break;
                    
                case "Response":
                    // ğŸ”¥ å‘½ä»¤å“åº”
                    OnCommandResponse?.Invoke(this, new CommandResponseArgs
                    {
                        InstanceId = instanceId,
                        CommandId = message.Data["CommandId"]?.ToString(),
                        Success = (bool)(message.Data["Success"] ?? false),
                        Result = message.Data["Result"]
                    });
                    break;
                    
                case "Heartbeat":
                    // ğŸ”¥ å¿ƒè·³å“åº”
                    await SendAsync(webSocket, new WebSocketMessage
                    {
                        Type = "HeartbeatAck",
                        Data = new { Timestamp = DateTime.Now }
                    });
                    break;
            }
        }
        
        /// <summary>
        /// å‘é€æ¶ˆæ¯åˆ°æŒ‡å®šæµè§ˆå™¨
        /// </summary>
        public async Task<bool> SendToInstanceAsync(string instanceId, WebSocketMessage message)
        {
            var connection = _connectionManager.GetConnection(instanceId);
            if (connection == null || connection.WebSocket.State != WebSocketState.Open)
            {
                return false;
            }
            
            return await SendAsync(connection.WebSocket, message);
        }
        
        /// <summary>
        /// å¹¿æ’­æ¶ˆæ¯åˆ°æ‰€æœ‰æµè§ˆå™¨
        /// </summary>
        public async Task BroadcastAsync(WebSocketMessage message)
        {
            var connections = _connectionManager.GetAllConnections();
            var tasks = connections.Select(c => SendAsync(c.WebSocket, message));
            await Task.WhenAll(tasks);
        }
        
        /// <summary>
        /// å‘é€æ¶ˆæ¯
        /// </summary>
        private async Task<bool> SendAsync(WebSocket webSocket, WebSocketMessage message)
        {
            try
            {
                var json = JsonConvert.SerializeObject(message);
                var bytes = Encoding.UTF8.GetBytes(json);
                await webSocket.SendAsync(
                    new ArraySegment<byte>(bytes), 
                    WebSocketMessageType.Text, 
                    true, 
                    CancellationToken.None);
                return true;
            }
            catch (Exception ex)
            {
                _logService.Error("WebSocketServer", "å‘é€æ¶ˆæ¯å¤±è´¥", ex);
                return false;
            }
        }
        
        /// <summary>
        /// è·å–æ‰€æœ‰å·²è¿æ¥çš„æµè§ˆå™¨
        /// </summary>
        public List<BrowserInstance> GetConnectedBrowsers()
        {
            return _connectionManager.GetAllConnections()
                .Select(c => new BrowserInstance
                {
                    InstanceId = c.InstanceId,
                    Platform = c.Platform,
                    Status = c.Status,
                    ConnectedTime = c.ConnectedTime
                })
                .ToList();
        }
        
        // ğŸ”¥ äº‹ä»¶
        public event EventHandler<BrowserEventArgs>? OnBrowserEvent;
        public event EventHandler<CommandResponseArgs>? OnCommandResponse;
        
        public async Task StopAsync()
        {
            _cts?.Cancel();
            _httpListener.Stop();
            await _connectionManager.CloseAllConnectionsAsync();
        }
    }
}
```

### 2. ConnectionManagerï¼ˆè¿æ¥ç®¡ç†å™¨ï¼‰

```csharp
namespace BaiShengVx3Plus.Services.AutoBet
{
    /// <summary>
    /// è¿æ¥ç®¡ç†å™¨ - ç®¡ç†æ‰€æœ‰æµè§ˆå™¨è¿æ¥
    /// </summary>
    public class ConnectionManager
    {
        private readonly ConcurrentDictionary<string, BrowserConnection> _connections;
        private readonly ILogService _logService;
        
        public ConnectionManager(ILogService logService)
        {
            _connections = new ConcurrentDictionary<string, BrowserConnection>();
            _logService = logService;
        }
        
        /// <summary>
        /// æ·»åŠ è¿æ¥
        /// </summary>
        public void AddConnection(string instanceId, WebSocket webSocket, dynamic registerData)
        {
            var connection = new BrowserConnection
            {
                InstanceId = instanceId,
                WebSocket = webSocket,
                Platform = registerData.Platform?.ToString() ?? "Unknown",
                Status = "Connected",
                ConnectedTime = DateTime.Now,
                LastHeartbeat = DateTime.Now
            };
            
            _connections[instanceId] = connection;
            _logService.Info("ConnectionManager", $"â• æ·»åŠ è¿æ¥: {instanceId}");
        }
        
        /// <summary>
        /// ç§»é™¤è¿æ¥
        /// </summary>
        public void RemoveConnection(string instanceId)
        {
            if (_connections.TryRemove(instanceId, out var connection))
            {
                _logService.Info("ConnectionManager", $"â– ç§»é™¤è¿æ¥: {instanceId}");
            }
        }
        
        /// <summary>
        /// è·å–è¿æ¥
        /// </summary>
        public BrowserConnection? GetConnection(string instanceId)
        {
            return _connections.TryGetValue(instanceId, out var connection) ? connection : null;
        }
        
        /// <summary>
        /// è·å–æ‰€æœ‰è¿æ¥
        /// </summary>
        public List<BrowserConnection> GetAllConnections()
        {
            return _connections.Values.ToList();
        }
        
        /// <summary>
        /// å…³é—­æ‰€æœ‰è¿æ¥
        /// </summary>
        public async Task CloseAllConnectionsAsync()
        {
            var tasks = _connections.Values
                .Select(c => c.WebSocket.CloseAsync(
                    WebSocketCloseStatus.NormalClosure, 
                    "Server closing", 
                    CancellationToken.None));
            await Task.WhenAll(tasks);
            _connections.Clear();
        }
        
        /// <summary>
        /// è·å–åœ¨çº¿æµè§ˆå™¨æ•°é‡
        /// </summary>
        public int GetOnlineCount()
        {
            return _connections.Count(c => c.Value.WebSocket.State == WebSocketState.Open);
        }
    }
    
    /// <summary>
    /// æµè§ˆå™¨è¿æ¥ä¿¡æ¯
    /// </summary>
    public class BrowserConnection
    {
        public string InstanceId { get; set; }
        public WebSocket WebSocket { get; set; }
        public string Platform { get; set; }
        public string Status { get; set; }
        public DateTime ConnectedTime { get; set; }
        public DateTime LastHeartbeat { get; set; }
    }
}
```

### 3. AutoBetDispatcherï¼ˆè®¢å•åˆ†å‘å™¨ï¼‰

```csharp
namespace BaiShengVx3Plus.Services.AutoBet
{
    /// <summary>
    /// è‡ªåŠ¨æŠ•æ³¨åˆ†å‘å™¨ - æ™ºèƒ½åˆ†é…è®¢å•åˆ°ä¸åŒæµè§ˆå™¨
    /// </summary>
    public class AutoBetDispatcher
    {
        private readonly BrowserWebSocketServer _wsServer;
        private readonly ILogService _logService;
        private readonly ConcurrentDictionary<string, TaskCompletionSource<BetResult>> _pendingBets;
        
        public AutoBetDispatcher(BrowserWebSocketServer wsServer, ILogService logService)
        {
            _wsServer = wsServer;
            _logService = logService;
            _pendingBets = new ConcurrentDictionary<string, TaskCompletionSource<BetResult>>();
            
            // ğŸ”¥ è®¢é˜…å‘½ä»¤å“åº”äº‹ä»¶
            _wsServer.OnCommandResponse += OnCommandResponse;
        }
        
        /// <summary>
        /// ğŸ”¥ åˆ†å‘è®¢å•åˆ°æŒ‡å®šæµè§ˆå™¨
        /// </summary>
        public async Task<BetResult> DispatchBetAsync(string instanceId, BetOrder order)
        {
            var commandId = Guid.NewGuid().ToString();
            var tcs = new TaskCompletionSource<BetResult>();
            _pendingBets[commandId] = tcs;
            
            try
            {
                // 1. å‘é€æŠ•æ³¨å‘½ä»¤
                var success = await _wsServer.SendToInstanceAsync(instanceId, new WebSocketMessage
                {
                    Type = "Command",
                    Data = new
                    {
                        CommandId = commandId,
                        CommandType = "PlaceBet",
                        Order = order
                    }
                });
                
                if (!success)
                {
                    return new BetResult { Success = false, ErrorMessage = "å‘é€å‘½ä»¤å¤±è´¥" };
                }
                
                _logService.Info("AutoBetDispatcher", 
                    $"ğŸ“¤ å‘é€è®¢å•åˆ° {instanceId}: {order.PlayType} {order.Amount}");
                
                // 2. ç­‰å¾…ç»“æœï¼ˆè¶…æ—¶30ç§’ï¼‰
                var resultTask = tcs.Task;
                var timeoutTask = Task.Delay(TimeSpan.FromSeconds(30));
                
                if (await Task.WhenAny(resultTask, timeoutTask) == timeoutTask)
                {
                    return new BetResult { Success = false, ErrorMessage = "æŠ•æ³¨è¶…æ—¶" };
                }
                
                return await resultTask;
            }
            finally
            {
                _pendingBets.TryRemove(commandId, out _);
            }
        }
        
        /// <summary>
        /// ğŸ”¥ æ‰¹é‡åˆ†å‘è®¢å•ï¼ˆè´Ÿè½½å‡è¡¡ï¼‰
        /// </summary>
        public async Task<List<BetResult>> DispatchBetsAsync(List<BetOrder> orders)
        {
            var browsers = _wsServer.GetConnectedBrowsers()
                .Where(b => b.Status == "Connected")
                .ToList();
            
            if (browsers.Count == 0)
            {
                _logService.Warning("AutoBetDispatcher", "æ²¡æœ‰å¯ç”¨çš„æµè§ˆå™¨");
                return orders.Select(o => new BetResult 
                { 
                    Success = false, 
                    ErrorMessage = "æ²¡æœ‰å¯ç”¨çš„æµè§ˆå™¨" 
                }).ToList();
            }
            
            // ğŸ”¥ ç®€å•è½®è¯¢åˆ†é…
            var tasks = orders.Select((order, index) =>
            {
                var browserIndex = index % browsers.Count;
                var browser = browsers[browserIndex];
                return DispatchBetAsync(browser.InstanceId, order);
            });
            
            return (await Task.WhenAll(tasks)).ToList();
        }
        
        /// <summary>
        /// ğŸ”¥ æ ¹æ®å¹³å°åˆ†å‘
        /// </summary>
        public async Task<BetResult> DispatchBetToPlatformAsync(
            PlatformType platform, 
            BetOrder order)
        {
            var browsers = _wsServer.GetConnectedBrowsers()
                .Where(b => b.Platform == platform.ToString() && b.Status == "Connected")
                .ToList();
            
            if (browsers.Count == 0)
            {
                return new BetResult 
                { 
                    Success = false, 
                    ErrorMessage = $"æ²¡æœ‰å¯ç”¨çš„ {platform} æµè§ˆå™¨" 
                };
            }
            
            // é€‰æ‹©ç¬¬ä¸€ä¸ªå¯ç”¨çš„æµè§ˆå™¨
            var browser = browsers.First();
            return await DispatchBetAsync(browser.InstanceId, order);
        }
        
        /// <summary>
        /// å¤„ç†å‘½ä»¤å“åº”
        /// </summary>
        private void OnCommandResponse(object? sender, CommandResponseArgs e)
        {
            if (e.CommandId != null && _pendingBets.TryGetValue(e.CommandId, out var tcs))
            {
                var result = new BetResult
                {
                    Success = e.Success,
                    OrderId = e.Result?["OrderId"]?.ToString(),
                    ErrorMessage = e.Result?["ErrorMessage"]?.ToString()
                };
                
                tcs.SetResult(result);
                
                _logService.Info("AutoBetDispatcher", 
                    $"ğŸ“¥ æ”¶åˆ°æŠ•æ³¨ç»“æœ: {e.InstanceId} - {(e.Success ? "æˆåŠŸ" : "å¤±è´¥")}");
            }
        }
    }
}
```

---

## ğŸ”Œ WebSocket Clientï¼ˆæµè§ˆå™¨ç«¯ï¼‰

```csharp
namespace BaiShengBrowser.Core
{
    /// <summary>
    /// WebSocket å®¢æˆ·ç«¯ - æµè§ˆå™¨ç«¯
    /// </summary>
    public class BrowserWebSocketClient
    {
        private ClientWebSocket _client;
        private readonly string _serverUrl;
        private readonly string _instanceId;
        private readonly PlatformType _platform;
        private readonly ILogService _logService;
        private CancellationTokenSource _cts;
        
        public BrowserWebSocketClient(
            string serverUrl, 
            string instanceId, 
            PlatformType platform,
            ILogService logService)
        {
            _serverUrl = serverUrl;
            _instanceId = instanceId;
            _platform = platform;
            _logService = logService;
        }
        
        /// <summary>
        /// è¿æ¥åˆ°æœåŠ¡å™¨
        /// </summary>
        public async Task<bool> ConnectAsync()
        {
            try
            {
                _client = new ClientWebSocket();
                _cts = new CancellationTokenSource();
                
                await _client.ConnectAsync(new Uri(_serverUrl), _cts.Token);
                _logService.Info("WebSocketClient", $"ğŸ”— å·²è¿æ¥åˆ°æœåŠ¡å™¨: {_serverUrl}");
                
                // ğŸ”¥ å‘é€æ³¨å†Œæ¶ˆæ¯
                await SendAsync(new WebSocketMessage
                {
                    Type = "Register",
                    Data = new
                    {
                        InstanceId = _instanceId,
                        Platform = _platform.ToString(),
                        Version = "1.0.0"
                    }
                });
                
                // ğŸ”¥ å¯åŠ¨æ¥æ”¶å¾ªç¯
                _ = ReceiveLoopAsync();
                
                // ğŸ”¥ å¯åŠ¨å¿ƒè·³
                _ = HeartbeatLoopAsync();
                
                return true;
            }
            catch (Exception ex)
            {
                _logService.Error("WebSocketClient", "è¿æ¥å¤±è´¥", ex);
                return false;
            }
        }
        
        /// <summary>
        /// æ¥æ”¶æ¶ˆæ¯å¾ªç¯
        /// </summary>
        private async Task ReceiveLoopAsync()
        {
            var buffer = new byte[4096];
            
            try
            {
                while (_client.State == WebSocketState.Open && !_cts.Token.IsCancellationRequested)
                {
                    var result = await _client.ReceiveAsync(
                        new ArraySegment<byte>(buffer), 
                        _cts.Token);
                    
                    if (result.MessageType == WebSocketMessageType.Close)
                    {
                        break;
                    }
                    
                    if (result.MessageType == WebSocketMessageType.Text)
                    {
                        var messageJson = Encoding.UTF8.GetString(buffer, 0, result.Count);
                        var message = JsonConvert.DeserializeObject<WebSocketMessage>(messageJson);
                        
                        // ğŸ”¥ å¤„ç†ä¸åŒç±»å‹çš„æ¶ˆæ¯
                        await HandleMessageAsync(message);
                    }
                }
            }
            catch (Exception ex)
            {
                _logService.Error("WebSocketClient", "æ¥æ”¶æ¶ˆæ¯å¤±è´¥", ex);
            }
        }
        
        /// <summary>
        /// å¤„ç†æ¶ˆæ¯
        /// </summary>
        private async Task HandleMessageAsync(WebSocketMessage message)
        {
            switch (message.Type)
            {
                case "Command":
                    // ğŸ”¥ æ‰§è¡Œå‘½ä»¤
                    await HandleCommandAsync(message.Data);
                    break;
                    
                case "HeartbeatAck":
                    // å¿ƒè·³å“åº”
                    break;
                    
                case "RegisterSuccess":
                    _logService.Info("WebSocketClient", "âœ… æ³¨å†ŒæˆåŠŸ");
                    OnConnected?.Invoke(this, EventArgs.Empty);
                    break;
            }
        }
        
        /// <summary>
        /// å¤„ç†å‘½ä»¤
        /// </summary>
        private async Task HandleCommandAsync(dynamic commandData)
        {
            var commandId = commandData.CommandId?.ToString();
            var commandType = commandData.CommandType?.ToString();
            
            try
            {
                object result = commandType switch
                {
                    "PlaceBet" => await ExecutePlaceBetAsync(commandData.Order),
                    "GetBalance" => await ExecuteGetBalanceAsync(),
                    "Login" => await ExecuteLoginAsync(commandData.Username, commandData.Password),
                    _ => new { Error = "æœªçŸ¥å‘½ä»¤" }
                };
                
                // ğŸ”¥ å‘é€å“åº”
                await SendAsync(new WebSocketMessage
                {
                    Type = "Response",
                    Data = new
                    {
                        CommandId = commandId,
                        Success = true,
                        Result = result
                    }
                });
            }
            catch (Exception ex)
            {
                _logService.Error("WebSocketClient", $"æ‰§è¡Œå‘½ä»¤å¤±è´¥: {commandType}", ex);
                
                // å‘é€é”™è¯¯å“åº”
                await SendAsync(new WebSocketMessage
                {
                    Type = "Response",
                    Data = new
                    {
                        CommandId = commandId,
                        Success = false,
                        Result = new { ErrorMessage = ex.Message }
                    }
                });
            }
        }
        
        /// <summary>
        /// å‘é€äº‹ä»¶åˆ°æœåŠ¡å™¨
        /// </summary>
        public async Task SendEventAsync(string eventType, object eventData)
        {
            await SendAsync(new WebSocketMessage
            {
                Type = "Event",
                Data = new
                {
                    EventType = eventType,
                    EventData = eventData
                }
            });
        }
        
        /// <summary>
        /// å‘é€æ¶ˆæ¯
        /// </summary>
        private async Task SendAsync(WebSocketMessage message)
        {
            if (_client.State != WebSocketState.Open)
                return;
            
            var json = JsonConvert.SerializeObject(message);
            var bytes = Encoding.UTF8.GetBytes(json);
            await _client.SendAsync(
                new ArraySegment<byte>(bytes), 
                WebSocketMessageType.Text, 
                true, 
                CancellationToken.None);
        }
        
        /// <summary>
        /// å¿ƒè·³å¾ªç¯
        /// </summary>
        private async Task HeartbeatLoopAsync()
        {
            while (_client.State == WebSocketState.Open && !_cts.Token.IsCancellationRequested)
            {
                try
                {
                    await SendAsync(new WebSocketMessage
                    {
                        Type = "Heartbeat",
                        Data = new { Timestamp = DateTime.Now }
                    });
                    
                    await Task.Delay(TimeSpan.FromSeconds(30), _cts.Token);
                }
                catch { break; }
            }
        }
        
        public event EventHandler? OnConnected;
        
        // å‘½ä»¤æ‰§è¡Œæ–¹æ³•ï¼ˆç”± BrowserHost å®ç°ï¼‰
        private async Task<object> ExecutePlaceBetAsync(dynamic order) { /* ... */ }
        private async Task<object> ExecuteGetBalanceAsync() { /* ... */ }
        private async Task<object> ExecuteLoginAsync(string username, string password) { /* ... */ }
    }
}
```

---

## ğŸ“Š æ¶ˆæ¯åè®®

### WebSocketMessage æ ¼å¼

```csharp
public class WebSocketMessage
{
    /// <summary>
    /// æ¶ˆæ¯ç±»å‹: Register, Command, Event, Response, Heartbeat
    /// </summary>
    public string Type { get; set; }
    
    /// <summary>
    /// æ¶ˆæ¯æ•°æ®ï¼ˆåŠ¨æ€ç±»å‹ï¼‰
    /// </summary>
    public dynamic Data { get; set; }
    
    /// <summary>
    /// æ—¶é—´æˆ³
    /// </summary>
    public DateTime Timestamp { get; set; } = DateTime.Now;
}
```

### æ¶ˆæ¯ç±»å‹

| Type | æ–¹å‘ | è¯´æ˜ | Data ç¤ºä¾‹ |
|------|------|------|-----------|
| **Register** | æµè§ˆå™¨â†’æœåŠ¡å™¨ | æµè§ˆå™¨æ³¨å†Œ | `{ InstanceId, Platform, Version }` |
| **RegisterSuccess** | æœåŠ¡å™¨â†’æµè§ˆå™¨ | æ³¨å†ŒæˆåŠŸ | `{ InstanceId }` |
| **Command** | æœåŠ¡å™¨â†’æµè§ˆå™¨ | æ‰§è¡Œå‘½ä»¤ | `{ CommandId, CommandType, ... }` |
| **Response** | æµè§ˆå™¨â†’æœåŠ¡å™¨ | å‘½ä»¤å“åº” | `{ CommandId, Success, Result }` |
| **Event** | æµè§ˆå™¨â†’æœåŠ¡å™¨ | äº‹ä»¶é€šçŸ¥ | `{ EventType, EventData }` |
| **Heartbeat** | æµè§ˆå™¨â†’æœåŠ¡å™¨ | å¿ƒè·³ | `{ Timestamp }` |
| **HeartbeatAck** | æœåŠ¡å™¨â†’æµè§ˆå™¨ | å¿ƒè·³å“åº” | `{ Timestamp }` |

---

## ğŸ¯ å¤šå®ä¾‹æ‰©å±•ç¤ºä¾‹

### ä½¿ç”¨ç¤ºä¾‹

```csharp
// ğŸ”¥ å¯åŠ¨ WebSocket æœåŠ¡å™¨
var wsServer = new BrowserWebSocketServer(8765, logService);
await wsServer.StartAsync();

// ğŸ”¥ åˆ›å»ºè®¢å•åˆ†å‘å™¨
var dispatcher = new AutoBetDispatcher(wsServer, logService);

// ğŸ”¥ åœºæ™¯1: å‘é€è®¢å•åˆ°æŒ‡å®šæµè§ˆå™¨
var order1 = new BetOrder 
{ 
    PlayType = "å¤§å°", 
    BetContent = "å¤§", 
    Amount = 100 
};
var result1 = await dispatcher.DispatchBetAsync("browser_1", order1);

// ğŸ”¥ åœºæ™¯2: å‘é€è®¢å•åˆ°æŒ‡å®šå¹³å°ï¼ˆè‡ªåŠ¨é€‰æ‹©æµè§ˆå™¨ï¼‰
var order2 = new BetOrder 
{ 
    PlayType = "å•åŒ", 
    BetContent = "å•", 
    Amount = 50 
};
var result2 = await dispatcher.DispatchBetToPlatformAsync(PlatformType.YunDing28, order2);

// ğŸ”¥ åœºæ™¯3: æ‰¹é‡è®¢å•ï¼ˆè‡ªåŠ¨è´Ÿè½½å‡è¡¡ï¼‰
var orders = new List<BetOrder>
{
    new BetOrder { PlayType = "å¤§å°", BetContent = "å¤§", Amount = 100 },
    new BetOrder { PlayType = "å•åŒ", BetContent = "å•", Amount = 50 },
    new BetOrder { PlayType = "ç‰¹ç ", BetContent = "5", Amount = 200 }
};
var results = await dispatcher.DispatchBetsAsync(orders);

// ğŸ”¥ åœºæ™¯4: æŸ¥è¯¢æ‰€æœ‰å·²è¿æ¥çš„æµè§ˆå™¨
var browsers = wsServer.GetConnectedBrowsers();
foreach (var browser in browsers)
{
    Console.WriteLine($"{browser.InstanceId} - {browser.Platform} - {browser.Status}");
}

// ğŸ”¥ åœºæ™¯5: å¹¿æ’­æ¶ˆæ¯åˆ°æ‰€æœ‰æµè§ˆå™¨
await wsServer.BroadcastAsync(new WebSocketMessage
{
    Type = "Command",
    Data = new { CommandType = "Refresh" }
});
```

---

## âœ… ä¼˜åŠ¿æ€»ç»“

### å¯¹æ¯” Named Pipes

| ç‰¹æ€§ | Named Pipes | WebSocket |
|------|------------|-----------|
| **å¤šè¿æ¥** | âŒ ä¸€å¯¹ä¸€ï¼Œéœ€å¤šä¸ªç®¡é“ | âœ… ä¸€å¯¹å¤šï¼Œä¸€ä¸ªæœåŠ¡å™¨ç®¡ç†æ‰€æœ‰ |
| **æ‰©å±•æ€§** | âŒ å·®ï¼Œç®¡é“åç®¡ç†å¤æ‚ | âœ… ä¼˜ç§€ï¼Œæ·»åŠ å®ä¾‹åªéœ€è¿æ¥ |
| **è·¯ç”±èƒ½åŠ›** | âŒ æ— ï¼Œéœ€è‡ªå·±å®ç° | âœ… æœ‰ï¼ŒåŸºäº InstanceId è·¯ç”± |
| **è´Ÿè½½å‡è¡¡** | âŒ éš¾å®ç° | âœ… æ˜“å®ç° |
| **ç›‘æ§ç®¡ç†** | âŒ éš¾ | âœ… æ˜“ï¼ˆè¿æ¥æ± ã€çŠ¶æ€æŸ¥è¯¢ï¼‰|
| **è·¨å¹³å°** | âŒ Windows only | âœ… è·¨å¹³å° |
| **è°ƒè¯•** | âŒ éš¾ | âœ… æ˜“ï¼ˆæµè§ˆå™¨å·¥å…·ã€æ—¥å¿—ï¼‰|

### æ‰©å±•èƒ½åŠ›

âœ… **æ”¯æŒä»»æ„æ•°é‡æµè§ˆå™¨**
```
VxMain (Server) â† 1 : N â†’ Browsers (Clients)
```

âœ… **ç²¾å‡†è·¯ç”±**
```csharp
// å‘é€åˆ°æŒ‡å®šå®ä¾‹
await server.SendToInstanceAsync("browser_123", message);
```

âœ… **å¹¿æ’­é€šçŸ¥**
```csharp
// å¹¿æ’­åˆ°æ‰€æœ‰æµè§ˆå™¨
await server.BroadcastAsync(message);
```

âœ… **è´Ÿè½½å‡è¡¡**
```csharp
// è‡ªåŠ¨åˆ†é…åˆ°ä¸åŒæµè§ˆå™¨
await dispatcher.DispatchBetsAsync(orders);
```

âœ… **åŠ¨æ€ç®¡ç†**
```csharp
// å®æ—¶æŸ¥è¯¢åœ¨çº¿æµè§ˆå™¨
var browsers = server.GetConnectedBrowsers();
```

---

## ğŸ‰ ç»“è®º

**é‡‡ç”¨ WebSocket é€šä¿¡æ–¹æ¡ˆï¼š**
1. âœ… å®Œç¾æ”¯æŒå¤šå®ä¾‹æ‰©å±•
2. âœ… æ˜“äºç®¡ç†å’Œç›‘æ§
3. âœ… æ”¯æŒè´Ÿè½½å‡è¡¡å’Œæ™ºèƒ½è·¯ç”±
4. âœ… ä»£ç ç®€æ´ã€æ˜“ç»´æŠ¤
5. âœ… æ€§èƒ½ä¼˜ç§€ã€è°ƒè¯•æ–¹ä¾¿

**æ¨èé‡‡ç”¨æ­¤æ–¹æ¡ˆï¼** ğŸš€

