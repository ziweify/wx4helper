# 数据存储架构重构方案

## 📊 当前问题

### 重复存储
- **数据库**（`app.db`）：存储所有任务（Name, Url, Username, Password, AutoLogin, Script路径等）
- **JSON 文件**（`*.json`）：每个任务一个文件，存储相同信息
- **问题**：数据重复，维护成本高，可能不一致

### 数据流混乱
```
启动时：数据库 → ScriptTask → ScriptTaskConfig → BrowserTaskControl
编辑时：BrowserTaskControl → JSON 文件（❌ 没有同步回数据库）
```

## 🎯 方案对比

### 方案1：完全统一到数据库（推荐）

**架构**：
- **唯一数据源**：SQLite 数据库（`app.db`）
- **移除**：JSON 配置文件（完全删除）
- **远程同步**：通过数据库导出/导入

**优点**：
- ✅ 单一数据源，避免不一致
- ✅ 简化架构，减少维护成本
- ✅ 数据库支持事务，更可靠
- ✅ 支持复杂查询和关系

**缺点**：
- ❌ 远程同步需要数据库服务器或导出 SQL
- ❌ 不能直接通过 HTTP API 同步单个配置

**实现**：
```csharp
// BrowserTaskControl 保存时
ConfigChanged?.Invoke(this, _config);
// → DataCollectionPage 订阅事件
// → task.UpdateFromConfig(config)
// → _dataCollectionService.SaveScriptTask(task) // 直接保存到数据库
```

**远程同步方式**：
- 方式1：导出 SQL 文件，通过 HTTP 上传/下载
- 方式2：使用数据库服务器（SQL Server/PostgreSQL），直接同步
- 方式3：导出 JSON（仅用于传输），导入时写入数据库

---

### 方案2：数据库为主，JSON 仅用于 HTTP 传输

**架构**：
- **主数据源**：SQLite 数据库
- **JSON**：仅作为 HTTP API 的传输格式（不持久化到本地文件）

**优点**：
- ✅ 数据库是唯一持久化存储
- ✅ JSON 仅用于 HTTP 传输，不重复存储
- ✅ 支持 RESTful API 同步

**缺点**：
- ⚠️ 需要区分"本地保存"和"远程同步"两种操作

**实现**：
```csharp
// 本地保存：直接保存到数据库
ConfigChanged?.Invoke(this, _config);
// → 保存到数据库

// 远程同步：临时生成 JSON，发送 HTTP，不保存本地文件
await SaveConfigToRemoteAsync(url);
// → 生成 JSON（内存中）
// → HTTP POST
// → 不保存到本地文件
```

---

### 方案3：数据库 + JSON 双写（当前方案，不推荐）

**架构**：
- **数据库**：存储任务列表
- **JSON**：每个任务一个文件，用于备份和远程同步

**优点**：
- ✅ 有备份（JSON 文件）
- ✅ 支持远程同步

**缺点**：
- ❌ 数据重复
- ❌ 需要同步机制
- ❌ 维护成本高
- ❌ 可能不一致

---

### 方案4：数据库为主，JSON 作为导出格式

**架构**：
- **主数据源**：SQLite 数据库
- **JSON**：仅用于导出/导入（手动操作，不自动保存）

**优点**：
- ✅ 数据库是唯一持久化存储
- ✅ JSON 用于备份和迁移
- ✅ 不自动保存，避免重复

**缺点**：
- ⚠️ 需要手动导出/导入

**实现**：
```csharp
// 移除自动保存 JSON
// 添加手动导出功能
public void ExportConfigToJson(string filePath) { ... }
public void ImportConfigFromJson(string filePath) { ... }
```

---

## 🔄 远程同步方式对比

### 方式1：HTTP API + JSON（当前）
```
客户端 → JSON → HTTP POST → 服务器 → 数据库
服务器 → 数据库 → JSON → HTTP GET → 客户端
```
**优点**：RESTful，标准格式，易于实现  
**缺点**：需要 JSON 作为中间格式

### 方式2：HTTP API + SQL
```
客户端 → SQL 导出 → HTTP POST → 服务器 → 执行 SQL
服务器 → SQL 导出 → HTTP GET → 客户端 → 执行 SQL
```
**优点**：直接操作数据库  
**缺点**：安全性差，需要执行 SQL

### 方式3：数据库服务器直接同步
```
客户端 ←→ SQL Server/PostgreSQL ←→ 服务器
```
**优点**：实时同步，事务支持  
**缺点**：需要数据库服务器，架构复杂

### 方式4：HTTP API + 自定义二进制格式
```
客户端 → 序列化 → HTTP POST → 服务器 → 反序列化 → 数据库
```
**优点**：体积小，速度快  
**缺点**：不便于调试，不标准

---

## 💡 推荐方案

### 推荐：方案2（数据库为主，JSON 仅用于 HTTP 传输）

**理由**：
1. **数据库是唯一持久化存储**：避免重复和不一致
2. **JSON 仅用于传输**：不保存到本地文件，避免重复
3. **支持远程同步**：通过 HTTP API 传输 JSON
4. **架构清晰**：职责分明

**实现步骤**：
1. 移除 `BrowserTaskControl` 的自动 JSON 保存
2. `ConfigChanged` 事件直接保存到数据库
3. 远程同步时，临时生成 JSON（内存中），发送 HTTP，不保存本地文件
4. 远程加载时，接收 JSON，写入数据库

---

## 📋 方案对比表

| 方案 | 数据源 | JSON 用途 | 远程同步 | 复杂度 | 推荐度 |
|------|--------|----------|----------|--------|--------|
| 方案1 | 仅数据库 | 无 | SQL/导出 | 低 | ⭐⭐⭐⭐ |
| 方案2 | 数据库 | HTTP 传输 | HTTP+JSON | 中 | ⭐⭐⭐⭐⭐ |
| 方案3 | 数据库+JSON | 持久化+传输 | HTTP+JSON | 高 | ⭐⭐ |
| 方案4 | 数据库 | 导出/导入 | 手动 | 低 | ⭐⭐⭐ |

---

## ❓ 需要确认的问题

1. **是否需要远程同步功能？**
   - 如果需要：选择方案2
   - 如果不需要：选择方案1

2. **远程同步的使用场景？**
   - 多设备同步？
   - 云端备份？
   - 团队共享？

3. **远程同步的频率？**
   - 实时同步？
   - 手动触发？
   - 定时同步？
