# 🎯 AI 代码修改工作规范与约束

## ⚠️ 核心原则

### 1. 最小化修改原则（最重要！）
```
❌ 错误做法：看到代码就想重构、优化、改进
✅ 正确做法：只修改用户明确要求修改的部分
```

**具体要求：**
- 用户说修改 A，就只修改 A，不要动 B、C、D
- 即使 B、C、D 看起来"可以优化"，也不要动
- 如果发现 B、C、D 有问题，**先告诉用户，等用户确认后再修改**

### 2. 参考现有代码原则
```
❌ 错误做法：按照"我的理解"写代码
✅ 正确做法：严格参照 F5BotV2 或现有代码的逻辑
```

**具体要求：**
- 用户说"参考 F5BotV2"，就去读 F5BotV2 的代码，**完全照抄逻辑**
- 不要自作主张添加"我认为更好"的逻辑
- 不要自作主张删除"我认为多余"的代码

### 3. 编译成功原则
```
❌ 错误做法：修改后不编译就提交
✅ 正确做法：每次修改后立即编译，确保没有错误
```

**具体要求：**
- 每次修改完成后，立即运行 `dotnet build` 编译
- 如果有编译错误，立即修复，直到编译成功
- 警告可以暂时忽略，但错误必须修复

### 4. 同步修改原则
```
❌ 错误做法：只修改 BaiShengVx3Plus，忘记修改 zhaocaimao
✅ 正确做法：同步修改所有相关项目
```

**具体要求：**
- 修改 `BaiShengVx3Plus` 时，同步修改 `zhaocaimao`
- 修改共享代码时，检查是否影响其他项目
- 修改完成后，编译所有相关项目

---

## 📋 详细工作流程

### 步骤1：理解需求
1. **仔细阅读用户的问题描述**
2. **确认问题范围：** 用户要求修改什么？
3. **确认参考代码：** 用户是否提到参考 F5BotV2？
4. **如果不确定，先问用户，不要猜！**

### 步骤2：定位问题
1. **使用 `codebase_search` 或 `grep` 查找相关代码**
2. **阅读现有代码，理解当前逻辑**
3. **如果用户提到参考代码，先读参考代码**

### 步骤3：最小化修改
1. **只修改必要的代码行**
2. **不要"顺便"修改其他代码**
3. **不要"优化"没有问题的代码**
4. **不要添加"我认为需要"的功能**

### 步骤4：编译验证
1. **立即编译修改的项目**
2. **如果有错误，立即修复**
3. **如果有警告，评估是否需要修复**

### 步骤5：同步修改
1. **检查是否需要同步修改其他项目**
2. **如果需要，使用相同的逻辑同步修改**
3. **编译所有相关项目**

### 步骤6：创建修复报告
1. **说明修改了什么**
2. **说明为什么修改**
3. **说明修改的影响范围**
4. **不要夸大其词，实事求是**

---

## ❌ 禁止行为清单

### 1. 禁止擅自重构
```csharp
❌ 禁止：看到代码就想"这个可以优化成..."
✅ 正确：用户没要求优化，就不要动
```

### 2. 禁止擅自添加功能
```csharp
❌ 禁止："我觉得这里应该加个日志"
✅ 正确：用户没要求加日志，就不要加
```

### 3. 禁止擅自删除代码
```csharp
❌ 禁止："我觉得这段代码没用，删掉"
✅ 正确：用户没说删，就不要删
```

### 4. 禁止自作主张修改逻辑
```csharp
❌ 禁止："我觉得用 A 方法比 B 方法好"
✅ 正确：现有代码用 B 方法，用户没要求改，就不要改
```

### 5. 禁止不编译就提交
```csharp
❌ 禁止：修改完就说"已完成"
✅ 正确：修改完→编译→成功→才说"已完成"
```

### 6. 禁止不同步修改
```csharp
❌ 禁止：只修改 BaiShengVx3Plus，忘记 zhaocaimao
✅ 正确：同步修改所有相关项目
```

---

## ✅ 正确行为示例

### 示例1：用户报告 Bug
**用户说：** "为什么浏览器又用到 configId 了，以前我们用的是配置名来匹配啊"

**正确做法：**
1. ✅ 搜索 `--config-id` 相关代码
2. ✅ 发现 `BrowserClient.cs` 第146行确实传递了 `--config-id`
3. ✅ **只修改这一行**，改成只传递 `--config-name`
4. ✅ 检查服务端是否支持 `browserConfigId == 0` 的情况
5. ✅ 如果不支持，修改服务端逻辑（最小化修改）
6. ✅ 编译验证
7. ✅ 同步修改 zhaocaimao 项目
8. ✅ 创建修复报告

**错误做法：**
1. ❌ "既然要改浏览器启动参数，我顺便把其他参数也优化一下"
2. ❌ "既然要改连接逻辑，我顺便把重连逻辑也重构一下"
3. ❌ "既然要改服务端，我顺便把监控任务也优化一下"

### 示例2：用户要求参考 F5BotV2
**用户说：** "请参考 F5BotV2 的解析方法，不要自作主张"

**正确做法：**
1. ✅ 打开 F5BotV2 的相关代码文件
2. ✅ **逐行阅读** F5BotV2 的逻辑
3. ✅ **完全照抄** F5BotV2 的逻辑（包括变量名、注释、算法）
4. ✅ 不要添加"我认为需要"的额外逻辑
5. ✅ 不要删除"我认为多余"的代码
6. ✅ 编译验证
7. ✅ 同步修改所有相关项目

**错误做法：**
1. ❌ "F5BotV2 的代码有点冗余，我优化一下"
2. ❌ "F5BotV2 这里逻辑不够清晰，我改写一下"
3. ❌ "F5BotV2 这里应该加个判断，我加上"

---

## 🔍 自我检查清单

每次修改前，问自己：
- [ ] 用户是否明确要求修改这部分？
- [ ] 我是否只修改了用户要求的部分？
- [ ] 我是否"顺便"修改了其他代码？
- [ ] 如果用户说参考 F5BotV2，我是否真的去读了 F5BotV2？
- [ ] 我是否自作主张添加了"我认为需要"的逻辑？
- [ ] 我是否自作主张删除了"我认为多余"的代码？

每次修改后，问自己：
- [ ] 我是否编译了修改的项目？
- [ ] 编译是否成功（0 个错误）？
- [ ] 我是否同步修改了所有相关项目？
- [ ] 我是否创建了修复报告？

---

## 🎓 经验教训总结

### 教训1：configId 问题
**错误：** 在之前的重构中，没有注意到浏览器启动时传递了 `--config-id`，导致数据库重建后连接失败。

**原因：** 没有完全理解现有代码的设计，擅自修改了连接逻辑。

**教训：** 
- ✅ 修改前，完整理解现有代码的设计意图
- ✅ 不要擅自修改"看起来可以优化"的代码
- ✅ 用户说"以前是用配置名匹配的"，说明以前的设计是对的，我改错了

### 教训2：BrowserClient.Dispose() 问题
**错误：** 在修复浏览器多开问题时，错误地在 `Dispose()` 中添加了 `_process.Kill()`，导致主程序关闭时浏览器被杀死，无法重连。

**原因：** 没有理解 `Dispose()` 的设计意图，擅自修改了它的行为。

**教训：**
- ✅ 修改前，理解方法的设计意图和调用时机
- ✅ 不要擅自添加"我认为需要"的逻辑
- ✅ 如果不确定，先问用户或查看历史代码

### 教训3：ProcessId 清理问题
**错误：** 在修复重连问题时，多次修改 ProcessId 的清理逻辑，导致越改问题越多。

**原因：** 没有系统性地理解 ProcessId 的生命周期，每次只修改一小部分，导致逻辑不一致。

**教训：**
- ✅ 修改前，系统性地理解整个生命周期
- ✅ 一次性修改所有相关的地方，保持逻辑一致
- ✅ 不要"头痛医头，脚痛医脚"

---

## 📞 与用户沟通规范

### 1. 如果不确定，先问用户
```
❌ 错误："我觉得应该这样改..."
✅ 正确："我看到有两种修改方案：A 和 B，请问您希望用哪种？"
```

### 2. 如果发现其他问题，先告诉用户
```
❌ 错误："我顺便把这个问题也修了..."
✅ 正确："我在修改时发现了另一个问题 X，是否需要一起修复？"
```

### 3. 如果修改可能影响其他功能，先告诉用户
```
❌ 错误："这个修改会影响 Y 功能，但应该没问题..."
✅ 正确："这个修改会影响 Y 功能，请问是否可以接受？"
```

### 4. 如果用户的需求不清楚，先澄清
```
❌ 错误："我猜用户的意思是..."
✅ 正确："请问您的意思是 A 还是 B？"
```

---

## 🎯 目标

**最终目标：**
- 用户说修改 A，我只修改 A
- 修改完成后，编译成功，功能正常
- 不会引入新的问题
- 不会"越修越多问题"

**评判标准：**
- 用户是否需要再次报告同样的问题？（应该：不需要）
- 修改是否引入了新的问题？（应该：没有）
- 修改的代码量是否最小？（应该：是）
- 修改的逻辑是否与现有代码一致？（应该：是）

---

**制定日期：** 2025-11-17  
**适用范围：** 所有 AI 代码修改工作  
**执行级别：** 强制执行，不得违反

