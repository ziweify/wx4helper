# 测试平台 - 网络超时模拟功能说明

## ✅ 修改完成

已将"测试平台"的投注返回值修改为模拟**网络超时**的情况。

---

## 📝 修改内容

### 文件：`BsBrowserClient/PlatformScripts/TestPlatformScript.cs`

### 方法：`PlaceBetAsync()`

**修改前**：返回投注成功的模拟数据

**修改后**：模拟远程服务器无响应，触发网络超时

---

## 🔧 实现逻辑

### 超时模拟

```csharp
// 🔥 模拟网络超时：等待超长时间（模拟远程服务器无响应）
_logCallback($"⏳ [测试平台] 模拟网络请求中...");
_logCallback($"⚠️ [测试平台] 正在等待远程服务器响应（模拟超时场景）...");

// 模拟超时：等待60秒
await Task.Delay(60000);  // 60秒超时

// 正常情况下不应该执行到这里，因为调用方会超时
_logCallback($"❌ [测试平台] 远程服务器响应超时");
throw new TimeoutException("远程服务器响应超时");
```

### 返回值

```csharp
catch (TimeoutException ex)
{
    _logCallback($"❌ [测试平台] 网络超时: {ex.Message}");
    return (false, "", "{\"status\":false,\"msg\":\"网络请求超时，远程服务器无响应\"}");
}
```

---

## 📋 旧代码保留

之前的成功返回逻辑已经**注释保留**，便于后续测试：

```csharp
#region 之前的成功返回值（保留，后续测试使用）

// // 检查余额
// if (_currentBalance < totalAmount)
// {
//     _logCallback($"❌ [测试平台] 余额不足: 当前{_currentBalance:F2}元 < 需要{totalAmount}元");
//     return (false, "", "{\"status\":false,\"msg\":\"余额不足\"}");
// }
// 
// // 模拟投注延迟
// await Task.Delay(300);
// 
// // 扣除余额
// _currentBalance -= totalAmount;
// 
// // 生成模拟订单号
// var orderId = $"TEST{DateTimeOffset.UtcNow.ToUnixTimeSeconds()}_{_orderCounter++}";
// 
// _logCallback($"✅ [测试平台] 投注成功: {orderId}");
// _logCallback($"💰 [测试平台] 剩余余额: {_currentBalance:F2} 元");
// 
// // 返回模拟响应（参考通宝格式）
// var response = new
// {
//     status = true,
//     BettingNumber = orderId,
//     msg = "投注成功",
//     balance = _currentBalance
// };
// 
// return (true, orderId, JsonConvert.SerializeObject(response));

#endregion
```

---

## 🧪 测试场景

### 预期行为

1. **用户发起投注**：
   ```
   投注(1234大10)
   ```

2. **浏览器日志显示**：
   ```
   🎲 [测试平台] 开始投注: 期号115003xxx 共4项 40元
      - P1 大: 10元
      - P2 大: 10元
      - P3 大: 10元
      - P4 大: 10元
   ⏳ [测试平台] 模拟网络请求中...
   ⚠️ [测试平台] 正在等待远程服务器响应（模拟超时场景）...
   ```

3. **系统超时处理**：
   - 如果系统设置了投注超时（例如10秒）
   - 系统应该在10秒后中断等待
   - 标记投注为"超时失败"或"待确认"

4. **日志记录**：
   ```
   ❌ [测试平台] 网络超时: 远程服务器响应超时
   ```

---

## 🎯 测试目的

### 验证系统对超时的处理

1. **超时检测**：系统是否能检测到投注超时？
2. **订单状态**：超时订单的状态如何标记？（待确认？失败？）
3. **重试机制**：系统是否会自动重试？
4. **用户反馈**：用户界面是否有明确的超时提示？
5. **数据一致性**：超时订单是否会导致数据不一致？

### 验证投注队列的健壮性

- 超时投注不应阻塞后续投注
- 系统应该能正确处理队列中的超时项
- 不应该因为一个超时而影响其他正常投注

---

## 🔄 如何恢复正常模拟

如果需要恢复正常的投注成功模拟，只需：

1. 删除超时模拟代码
2. 取消注释 `#region` 内的旧代码
3. 重新编译

或者直接修改超时时间为很短的延迟：

```csharp
// 从
await Task.Delay(60000);  // 60秒超时

// 改为
await Task.Delay(300);  // 300毫秒正常响应
// 然后继续执行成功逻辑
```

---

## ⚙️ 编译状态

```
✅ BsBrowserClient 编译成功
```

---

## 📝 使用建议

### 测试步骤

1. **启动程序**
2. **选择测试平台**
3. **发起投注**
4. **观察行为**：
   - 系统如何响应超时？
   - 日志记录是否完整？
   - 订单状态是否正确？
5. **检查数据库**：
   - 订单是否被正确标记？
   - 是否有遗留的"进行中"状态？

### 测试重点

- ✅ 超时检测机制
- ✅ 订单状态管理
- ✅ 错误日志记录
- ✅ 用户界面反馈
- ✅ 投注队列健壮性
- ✅ 数据一致性保证

---

**修改完成！现在"测试平台"会模拟真实的网络超时场景！** ⏳
