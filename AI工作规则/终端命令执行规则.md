# Cursor 终端命令执行规则

**📅 创建日期**: 2025-12-19  
**🎯 目的**: 规范AI在Cursor中执行终端命令的方式，避免中文路径编码问题  
**⚠️ 重要性**: 必须严格遵守，这是长期反复出现的问题

---

## 🔴 核心问题说明

### 问题根源
- **`run_terminal_cmd`工具的限制**：该工具通过创建临时PowerShell脚本文件（`.ps1`）来执行命令
- **临时脚本的编码问题**：这些临时文件的UTF-8编码处理不完善，导致中文路径无法正确识别
- **表现形式**：
  ```
  cd : 找不到路径"E:\gitcode\wx4helper\永利系统\项目说明"，因为该路径不存在。
  ```
  但实际上路径是存在的，只是编码问题导致无法识别

### ⭐ 关键发现：工具实现差异

**重要对比**：

| 工具 | 文件位置 | 编码处理 | 中文支持 | 可用性 |
|------|---------|---------|---------|--------|
| `write`工具 | 项目目录 | ✅ UTF-8正确 | ✅ 完全支持 | ✅ 推荐使用 |
| `run_terminal_cmd`工具 | 临时目录 | ❌ 编码错误 | ❌ 中文损坏 | ❌ 不适用于中文 |

**实际验证**：
- ✅ `永利系统/重命名文件.ps1`（使用`write`工具创建）→ 中文完全正常
- ❌ `C:\Users\...\Temp\ps-script-xxx.ps1`（使用`run_terminal_cmd`创建）→ 中文乱码

**结论**：
- 问题不在"文件写入"本身
- 问题在`run_terminal_cmd`工具的**实现缺陷**
- `write`工具的实现是正确的，可以作为替代方案

### 已验证的无效方案
以下方案都**无法解决**问题（已实际测试）：

❌ **在命令中注入 `chcp 65001`**
```powershell
chcp 65001; cd "中文路径"  # 无效！
```
**原因**：虽然运行时编码设置成功（显示 `Active code page: 65001`），但临时脚本文件在写入时中文字符就已经损坏（显示为乱码如`姘稿埄绯荤粺`），运行时设置编码为时已晚。

❌ **设置PowerShell输出编码**
```powershell
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8; cd "中文路径"  # 无效！
```
**原因**：只影响输出显示，不影响脚本文件本身的编码。

❌ **使用 `-LiteralPath` 参数**
```powershell
Rename-Item -LiteralPath "中文路径"  # 无效！
```
**原因**：参数本身包含中文，在脚本文件中已经损坏。

❌ **使用绝对路径**
```powershell
cd "E:\完整\的\中文\路径"  # 无效！
```
**原因**：绝对路径也包含中文，问题相同。

### 问题本质
**临时脚本文件编码问题**：
- `run_terminal_cmd` 创建临时 `.ps1` 文件时的编码不是正确的UTF-8
- 或者是UTF-8但没有BOM，导致PowerShell无法正确识别
- 或者是系统的默认编码（GBK/GB2312）与UTF-8混合导致损坏
- **总之，中文字符在写入临时脚本文件时就已经损坏，后续任何运行时的编码设置都无济于事**

### 用户环境说明
- ✅ **用户的Cursor终端环境完全正常**，支持中文路径
- ✅ **用户的本地PowerShell完全正常**，可以处理中文
- ❌ **只有AI通过`run_terminal_cmd`工具执行时才会有问题**

---

## ✅ 正确的执行方式

### 规则1: 涉及中文路径时，不使用`run_terminal_cmd`

**禁止做法** ❌：
```
使用 run_terminal_cmd 工具执行包含中文路径的命令
```

**正确做法** ✅：
1. **创建批处理脚本（.bat）或PowerShell脚本（.ps1）文件**
2. **告知用户在终端中手动执行**
3. **提供完整的命令让用户复制粘贴**

### 规则2: 创建可执行脚本而不是直接执行

**示例**：需要在中文路径下重命名文件

**错误做法** ❌：
```javascript
run_terminal_cmd({
  command: 'cd "E:\\gitcode\\wx4helper\\永利系统\\项目说明"; Rename-Item ...',
  explanation: '重命名文件'
})
```

**正确做法** ✅：

**步骤1**: 创建批处理脚本
```javascript
write({
  file_path: '永利系统/项目说明/rename.bat',
  contents: `@echo off
chcp 65001 >nul
cd /d "E:\\gitcode\\wx4helper\\永利系统\\项目说明"
ren "old.md" "new.md"
echo 完成！
pause`
})
```

**步骤2**: 告知用户执行方式
```
请在Cursor终端中执行以下命令：
cd "E:\gitcode\wx4helper\永利系统\项目说明"
.\rename.bat

或者直接在文件资源管理器中双击 rename.bat 文件
```

### 规则3: 提供多种执行方案

为用户提供至少2-3种选择：

1. **在Cursor终端中执行**（最推荐）
   ```powershell
   cd "中文路径"
   执行命令
   ```

2. **双击批处理脚本**
   - 创建.bat文件
   - 告知用户双击运行

3. **手动操作**
   - 提供详细的手动操作步骤
   - 适用于简单的文件操作

---

## 📋 具体场景处理规范

### 场景1: 文件重命名

**任务**: 在`E:\gitcode\wx4helper\永利系统\项目说明`下重命名文件

**正确流程**:

1. **创建批处理脚本**
   ```batch
   @echo off
   chcp 65001 >nul
   cd /d "E:\gitcode\wx4helper\永利系统\项目说明"
   ren "old.md" "new.md"
   echo ✅ 完成！
   pause
   ```

2. **同时提供PowerShell命令**（让用户在终端中执行）
   ```powershell
   cd "E:\gitcode\wx4helper\永利系统\项目说明"
   Rename-Item "old.md" "new.md"
   ```

3. **说明**
   ```
   由于run_terminal_cmd工具对中文路径的编码限制，
   请您直接在Cursor终端中复制粘贴以上命令执行。
   
   或者双击运行已创建的批处理脚本：
   E:\gitcode\wx4helper\永利系统\项目说明\rename.bat
   ```

### 场景2: 批量文件操作

**任务**: 需要批量处理多个文件

**正确流程**:

1. **创建详细的批处理脚本**（包含所有操作）
2. **创建操作指南文档**（说明每一步）
3. **提供命令列表**（供用户在终端中执行）

**不要**:
- ❌ 尝试用`run_terminal_cmd`执行复杂的批量操作
- ❌ 使用多个`run_terminal_cmd`调用来逐个处理
- ❌ 尝试通过设置编码来"修复"`run_terminal_cmd`

### 场景3: 纯英文路径操作

**任务**: 在不包含中文的路径下执行命令

**可以使用** `run_terminal_cmd`:
```javascript
run_terminal_cmd({
  command: 'cd C:\\Projects\\MyApp; dotnet build',
  explanation: '构建项目'
})
```

**注意**: 即使是英文路径，如果命令输出包含中文，也可能显示乱码（但不影响执行）

---

## 🎯 判断标准

### 何时可以使用 `run_terminal_cmd`

✅ **可以使用的情况**:
- 纯英文路径
- 命令本身不包含中文字符
- 简单的查询命令（如`dir`, `ls`, `pwd`）
- 不依赖正确显示中文输出的命令

❌ **禁止使用的情况**:
- 路径包含中文字符
- 文件名包含中文字符
- 命令参数包含中文
- 需要正确处理中文输入/输出的任何操作

### 快速判断法

**问自己**: "这个命令或路径中有中文吗？"
- **有** → 创建脚本 + 让用户执行
- **没有** → 可以使用`run_terminal_cmd`

---

## 📝 标准回复模板

### 模板1: 中文路径操作

```
由于您的操作涉及中文路径，Cursor的run_terminal_cmd工具
存在编码限制，请您直接在Cursor终端中执行以下命令：

【命令内容】

我已经为您创建了批处理脚本：【文件路径】
您也可以直接双击该文件执行。
```

### 模板2: 已创建脚本

```
✅ 已为您创建执行脚本：【文件路径】

执行方式（任选一种）：
1. 在Cursor终端中执行：
   cd "【目录】"
   .\【脚本名】

2. 在文件资源管理器中双击脚本文件

3. 手动执行以下命令：
   【命令列表】
```

---

## 🚫 常见错误示例

### 错误1: 反复尝试设置编码

**错误做法**:
```javascript
// 尝试1
run_terminal_cmd({ command: '[Console]::OutputEncoding = [System.Text.Encoding]::UTF8; cd 中文路径' })

// 尝试2  
run_terminal_cmd({ command: 'chcp 65001; cd 中文路径' })

// 尝试3
run_terminal_cmd({ command: '$OutputEncoding = [Text.UTF8Encoding]::UTF8; cd 中文路径' })
```

**为什么错误**: 
- **临时脚本文件本身的编码就有问题**（这是根本原因）
- 中文字符在写入临时脚本文件时就已经损坏（变成乱码如`姘稿埄绯荤粺`）
- 运行时设置编码只影响命令执行环境，无法修复已损坏的脚本内容
- 这是Cursor的`run_terminal_cmd`工具的已知限制

**实际测试结果**:
```
命令: chcp 65001; cd "E:\gitcode\wx4helper\永利系统\项目说明"
结果: Active code page: 65001  ← 编码设置成功
      cd : 找不到路径"...姘稿埄绯荤粺\椤圭洰璇存槑"  ← 但路径已是乱码
```

**正确做法**:
- 直接创建脚本文件（使用`write`工具）
- 让用户在正常的终端环境中执行
- 不要寄希望于运行时编码设置

### 错误2: 使用绝对路径"规避"问题

**错误做法**:
```javascript
run_terminal_cmd({ 
  command: 'Rename-Item -LiteralPath "E:\\完整\\中文\\路径\\file.txt" ...'
})
```

**为什么错误**:
- 绝对路径也包含中文，问题依然存在
- `-LiteralPath`不能解决编码问题

### 错误3: 分步执行

**错误做法**:
```javascript
// 第一步
run_terminal_cmd({ command: 'cd 中文目录' })

// 第二步
run_terminal_cmd({ command: 'ren file1.txt newname.txt' })
```

**为什么错误**:
- 第一步就失败了，后续无法继续
- 每次调用都创建新的临时脚本，状态不保持

---

## ✅ 最佳实践总结

### DO ✅

1. **创建脚本文件**（.bat, .ps1）让用户执行
2. **提供完整命令**供用户复制粘贴
3. **提供多种执行方式**（终端/双击/手动）
4. **创建详细的操作指南**
5. **说明为什么需要用户手动执行**（透明沟通）

### DON'T ❌

1. **不要**尝试用`run_terminal_cmd`执行包含中文路径的命令
2. **不要**反复尝试设置编码"修复"问题
3. **不要**使用复杂的转义或编码技巧
4. **不要**假设问题是用户环境的问题
5. **不要**在失败后继续尝试相同的方法

---

## 📊 决策流程图

```
开始
  ↓
命令/路径包含中文？
  ↓
是 ────→ 创建脚本文件
  │        ↓
  │      提供执行说明
  │        ↓
  │      (可选)提供手动操作步骤
  │        ↓
  │      结束
  ↓
否
  ↓
可以使用 run_terminal_cmd
  ↓
执行命令
  ↓
结束
```

---

## 🔍 故障排查

### 如果用户报告"命令不工作"

1. **检查是否使用了`run_terminal_cmd`处理中文路径**
   - 如果是 → 这就是问题所在
   - 解决：改用创建脚本的方式

2. **检查用户的执行方式**
   - 是在Cursor终端中执行？✅
   - 还是期望AI自动执行？❌（需要说明限制）

3. **验证脚本内容**
   - 路径是否正确？
   - 命令语法是否正确？
   - 编码设置（chcp 65001）是否包含？

---

## 📌 记住

1. **用户的环境是正常的**
   - Cursor终端支持中文
   - 本地PowerShell支持中文
   - 问题出在AI的工具调用上

2. **run_terminal_cmd的限制是已知的**
   - 这是Cursor的限制，不是bug
   - 无法通过编码设置修复
   - 必须采用替代方案

3. **用户可以自己执行命令**
   - 提供清晰的命令
   - 提供多种执行方式
   - 创建可执行脚本

4. **沟通很重要**
   - 说明为什么需要用户手动执行
   - 不要让用户觉得是他们的环境有问题
   - 提供完整的解决方案

---

## 🎯 执行检查清单

在执行涉及文件系统操作的任务前，检查：

- [ ] 路径是否包含中文？
- [ ] 文件名是否包含中文？
- [ ] 命令参数是否包含中文？
- [ ] 如果任何一项为"是"→ 使用创建脚本方式
- [ ] 如果全部为"否"→ 可以使用run_terminal_cmd

---

## 📚 相关文档

- 本规则文件：`AI工作规则/终端命令执行规则.md`
- 问题案例：`永利系统/项目说明/251219-013-重命名操作指南.md`
- PowerShell中文路径说明：`永利系统/项目说明/README-命名规则.md`

---

---

## 📄 PowerShell脚本文件编码规则

### 问题：脚本文件执行时的编码问题

即使使用`write`工具创建了脚本文件，如果脚本中包含中文字符串，在执行时仍可能出现编码错误：

**错误示例**：
```powershell
# 脚本内容
$title = "本地DLL引用"  # 中文字符串
Rename-Item "old.md" "new-$title.md"
```

**错误信息**：
```
表达式或语句中包含意外的标记"}"
字符串缺少终止符: "
```

### 原因分析

1. **脚本文件编码问题**：
   - PowerShell默认期望脚本文件是UTF-8 with BOM编码
   - 如果脚本是UTF-8 without BOM，中文字符串可能被错误解析
   - Cursor的`write`工具可能创建UTF-8 without BOM的文件

2. **字符串字面量问题**：
   - 脚本中的中文字符串字面量在解析时可能出错
   - 即使文件编码正确，PowerShell解析器也可能误解中文字符

### ✅ 解决方案

#### 方案1: 使用Base64编码存储中文字符串（推荐）

**优点**：完全避免编码问题，最可靠

**示例**：
```powershell
# 使用Base64编码存储中文字符串
function Decode-UTF8Base64 {
    param([string]$base64)
    $bytes = [System.Convert]::FromBase64String($base64)
    return [System.Text.Encoding]::UTF8.GetString($bytes)
}

# 中文字符串使用Base64编码
$title = Decode-UTF8Base64 "6Y+I7oSA5rm0RExM5a+u5pug5pWk"  # "本地DLL引用"
$newName = "251219-002-$title.md"
```

**完整示例**：
```powershell
# 修复乱码文件名的脚本
$fixMap = @{}
$fixMap["251219-002-鏈湴DLL寮曠敤.md"] = "251219-002-" + (Decode-UTF8Base64 "6Y+I7oSA5rm0RExM5a+u5pug5pWk") + ".md"
$fixMap["251219-003-寮曠敤缂哄け瑙ｅ喅.md"] = "251219-003-" + (Decode-UTF8Base64 "5a+u5pug5pWk57yC5ZOE44GR55GZ772F5ZaF") + ".md"
```

#### 方案2: 确保脚本文件是UTF-8 with BOM

**步骤**：
1. 创建脚本后，告知用户检查编码
2. 提供转换脚本（如`转换为UTF8BOM.ps1`）
3. 或提供手动转换方法

**转换脚本示例**：
```powershell
# 转换为UTF8BOM.ps1
$content = Get-Content "script.ps1" -Raw -Encoding UTF8
$utf8WithBOM = New-Object System.Text.UTF8Encoding $true
[System.IO.File]::WriteAllText("script.ps1", $content, $utf8WithBOM)
```

#### 方案3: 避免在脚本中使用中文字符串字面量

**方法**：
- 使用变量存储，通过Base64解码
- 从文件读取（文件本身是UTF-8 with BOM）
- 使用参数传递（用户在终端输入）

### 📋 PowerShell脚本创建检查清单

创建PowerShell脚本时，检查：

- [ ] 脚本是否包含中文字符串字面量？
  - 是 → 使用Base64编码存储 ✅
  - 否 → 可以直接使用 ✅
- [ ] 脚本文件编码是否为UTF-8 with BOM？
  - 不确定 → 提供转换脚本或说明 ✅
- [ ] 是否提供了多种执行方式？
  - 是 → 包括终端执行、批处理脚本、手动操作 ✅

### 🎯 PowerShell脚本最佳实践

#### DO ✅

1. **使用Base64编码存储中文字符串**
   ```powershell
   $title = Decode-UTF8Base64 "6Y+I7oSA5rm0RExM5a+u5pug5pWk"
   ```

2. **提供编码转换工具**
   - 创建`转换为UTF8BOM.ps1`脚本
   - 告知用户如何检查文件编码

3. **在脚本开头设置编码**
   ```powershell
   [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
   $OutputEncoding = [System.Text.Encoding]::UTF8
   ```

4. **使用相对路径和变量**
   ```powershell
   $baseDir = Split-Path -Parent $MyInvocation.MyCommand.Path
   $targetDir = Join-Path $baseDir "项目说明"
   ```

#### DON'T ❌

1. **不要在脚本中直接使用中文字符串字面量**
   ```powershell
   # ❌ 错误
   $title = "本地DLL引用"
   ```

2. **不要假设脚本文件编码正确**
   - 总是提供编码检查和转换方法

3. **不要忽略编码错误**
   - 如果用户报告编码错误，立即提供Base64编码方案

### 📝 标准脚本模板

```powershell
# PowerShell脚本模板 - 支持中文
# 注意：中文字符串使用Base64编码

[Console]::OutputEncoding = [System.Text.Encoding]::UTF8
$OutputEncoding = [System.Text.Encoding]::UTF8

# Base64解码函数
function Decode-UTF8Base64 {
    param([string]$base64)
    $bytes = [System.Convert]::FromBase64String($base64)
    return [System.Text.Encoding]::UTF8.GetString($bytes)
}

# 获取脚本所在目录
$baseDir = Split-Path -Parent $MyInvocation.MyCommand.Path

# 使用Base64编码的中文字符串
$title = Decode-UTF8Base64 "6Y+I7oSA5rm0RExM5a+u5pug5pWk"  # "本地DLL引用"

# 脚本逻辑...
```

### 🔍 故障排查

#### 如果用户报告"脚本执行错误：意外的标记"

1. **检查脚本中是否包含中文字符串字面量**
   - 如果有 → 改为Base64编码 ✅

2. **检查脚本文件编码**
   - 使用`转换为UTF8BOM.ps1`转换 ✅

3. **检查PowerShell版本**
   - PowerShell 5.1+ 和 PowerShell Core 7+ 对编码处理不同
   - 建议使用Base64编码方案（兼容性最好）✅

#### 如果用户报告"文件名还是乱码"

1. **检查映射表中的键值**
   - 键（旧文件名）必须与实际文件名完全匹配
   - 值（新文件名）必须使用Base64解码后的正确中文 ✅

2. **验证Base64编码是否正确**
   - 提供测试脚本验证解码结果 ✅

---

**规则版本**: v1.1  
**创建日期**: 2025-12-19  
**最后更新**: 2025-12-19  
**适用范围**: 所有涉及Cursor终端命令执行和PowerShell脚本创建的操作  
**强制执行**: 是 ✅

