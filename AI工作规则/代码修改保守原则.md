# 代码修改保守原则

**优先级**: 🔴 最高  
**适用场景**: 所有代码修改  
**制定时间**: 2026-01-24

---

## 🎯 核心原则

> **如果它没有坏，就不要修它！**  
> **If it ain't broke, don't fix it!**

---

## 📋 详细规则

### 1. 只修改明确要求的代码

#### ✅ 允许修改的情况

1. **用户明确指出的问题**
   - 用户报告了BUG
   - 用户要求新增功能
   - 用户要求优化性能

2. **直接相关的必要修改**
   - 修复编译错误
   - 修复运行时异常
   - 必须的依赖更新

#### ❌ 禁止修改的情况

1. **"顺便优化"** - 禁止
   ```
   ❌ "我看到这里可以改得更好"
   ❌ "这里格式不统一，我顺便改一下"
   ❌ "这个命名不规范，我改成更好的"
   ```

2. **"预防性修改"** - 禁止
   ```
   ❌ "这里可能会有问题，我预防一下"
   ❌ "为了统一，我把其他地方也改了"
   ❌ "这个方法太老了，我用新方法重写"
   ```

3. **"标准化修改"** - 需明确要求
   ```
   ❌ "我发现格式不统一，我全部统一"
   ⚠️  需要用户明确说：请统一格式
   ```

---

## 🔍 具体案例

### 案例1：错误码系统（本次教训）

#### ❌ 错误做法
```
用户说：添加错误码到异常处理
AI做了：
  1. ✅ 给数据库事务失败添加错误码（正确）
  2. ✅ 给BindingSource异常添加错误码（正确）
  3. ❌ 给余额不足提示添加错误码（过度）👈 这是正常业务提示！
```

#### ✅ 正确做法
```
用户说：添加错误码到异常处理
AI应该：
  1. ✅ 只给真正的异常（catch块）添加错误码
  2. ✅ 正常的业务提示（如"存储不足!"）保持原样
  3. ✅ 如果不确定，先问用户
```

#### 📝 分析
- **余额不足** 是**正常业务逻辑**，不是异常
- 原有的 `"@{nickname} 存储不足!"` 是**正确的业务提示**
- 不需要错误码，因为它不是系统错误

---

### 案例2：正确的修改范围

#### ✅ 用户要求：修复BindingSource异常导致重复上分

**应该修改的**:
```csharp
// 1. 重新排序事务和UI更新
lock (MemberBalanceLock) {
    _db.BeginTransaction();
    _db.Update(member);
    _db.Update(request);
    _db.Commit();  // ✅ 先提交
}
// UI更新放在锁外  // ✅ 后更新UI
```

**不应该修改的**:
```csharp
// ❌ 不要改这些正常工作的代码
if (member.Balance < amount) {
    SendMessage("存储不足!");  // ✅ 保持原样
    return;
}
```

---

## 🎯 判断标准

### 问自己3个问题

1. **用户明确要求了吗？**
   - ❌ 没有 → 不要改
   - ✅ 有 → 可以改

2. **这是BUG还是风格问题？**
   - ✅ BUG → 必须改
   - ❌ 风格 → 不要改

3. **不改会影响用户要求的功能吗？**
   - ✅ 会 → 可以改
   - ❌ 不会 → 不要改

---

## 📊 修改范围控制

### 最小化原则

```
用户要求 → 分析影响范围 → 最小化修改

例如：
用户说：修复订单创建BUG

✅ 应该改：
  - BinggoOrderService.CreateOrderAsync()
  - 相关的锁逻辑
  - 必要的日志

❌ 不应该改：
  - 其他Service的代码
  - UI展示代码（除非影响功能）
  - 命名、格式、注释（除非用户要求）
```

---

## 🚨 特别注意

### 1. 业务逻辑 vs 系统错误

| 类型 | 示例 | 需要错误码？ |
|------|------|------------|
| 业务逻辑 | 余额不足、期号已封盘 | ❌ 不需要 |
| 系统错误 | 数据库失败、网络超时 | ✅ 需要 |

### 2. 正常提示 vs 异常通知

```csharp
// ✅ 正常业务提示 - 保持原样
if (balance < amount) {
    SendMessage("@user 存储不足!");  // 不需要错误码
    return;
}

// ✅ 异常通知 - 使用错误码
try {
    _db.Commit();
} catch (Exception ex) {
    SendMessage("@user 系统错误[SYS-204]");  // 需要错误码
    throw;
}
```

### 3. 已有代码的价值

```
已经运行的代码 = 经过实战验证的代码

特点：
  ✅ 可能格式不完美，但功能正确
  ✅ 可能写法老旧，但稳定可靠
  ✅ 可能命名不规范，但大家都懂

价值：
  🔴 稳定性 > 代码美观
  🔴 可维护性 > 最新技术
  🔴 实用性 > 理论完美
```

---

## ✅ 正确的工作流程

### Step 1: 理解需求
```
用户说：修复XX问题
↓
1. 确认问题范围
2. 定位问题代码
3. 分析影响范围
```

### Step 2: 最小化修改
```
定位到的问题代码
↓
1. 只改必须改的
2. 相关的必改项
3. 不改其他代码
```

### Step 3: 验证修改
```
修改完成
↓
1. 编译通过
2. 功能正确
3. 没有破坏其他功能
```

---

## 🎓 学习案例

### 反例：过度修改（本次）

```diff
用户要求：异常处理添加错误码

我改了：
+ CreditWithdrawService.cs - catch块添加错误码 ✅ 正确
+ AdminCommandHandler.cs - catch块添加错误码 ✅ 正确
- CreditWithdrawService.cs - 余额不足改错误码 ❌ 过度
- CreditWithdrawManageForm.cs - 余额不足改错误码 ❌ 过度

教训：
  1. 余额不足是业务逻辑，不是异常
  2. 原有的"存储不足!"是正确的
  3. 不应该修改正常工作的代码
```

### 正例：精确修改

```diff
用户要求：修复BindingSource异常导致重复上分

我只改了：
+ CreditWithdrawService.ProcessCreditWithdraw() - 事务顺序 ✅
+ AdminCommandHandler.ExecuteCreditWithdraw() - 调用服务层 ✅

没有改：
  = 余额检查逻辑 ✅ 保持不变
  = 微信通知格式 ✅ 保持不变
  = 其他正常代码 ✅ 保持不变
```

---

## 📝 总结

### 核心要点

1. **只改用户要求的** - 不要主动优化
2. **区分业务和异常** - 业务提示不需要错误码
3. **尊重已有代码** - 能工作的就是好代码
4. **最小化修改** - 改得越少越好
5. **不确定就问** - 别自作主张

### 记住这句话

> **代码修改的最高境界：**  
> **修复BUG而不引入新问题**  
> **改一处代码，不影响其他**

---

## 🔐 强制检查清单

在提交代码前，必须回答：

- [ ] 这个修改是用户明确要求的吗？
- [ ] 这个修改是修复BUG必需的吗？
- [ ] 我改的是异常处理，不是正常业务逻辑吧？
- [ ] 我没有"顺便优化"其他代码吧？
- [ ] 我没有修改正常工作的代码吧？

**如果有任何"否"或"不确定"，先问用户！**

---

**制定人**: AI Assistant  
**审核人**: 用户  
**生效日期**: 2026-01-24  
**优先级**: 🔴 最高 - 必须严格遵守
