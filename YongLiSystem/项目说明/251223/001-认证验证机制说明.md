# 认证验证机制说明

## 📋 验证密钥说明

### 验证密钥定义
```csharp
private const int _verifyKey1 = unchecked((int)0x4A3F2E1D);  // 十六进制密钥1
private const int _verifyKey2 = unchecked((int)0x8B7C6D5E);  // 十六进制密钥2
private const string _verifySecret = "YLXT_AUTH_2024";        // 字符串密钥
```

### 验证过程详解

#### 1. 密钥混淆验证（VerifyAntiCrack 方法）

**验证步骤：**

```csharp
// 步骤1：对密钥进行异或运算（混淆）
var key1 = _verifyKey1 ^ 0x12345678;  // 0x4A3F2E1D ^ 0x12345678 = ?
var key2 = _verifyKey2 ^ 0x87654321;  // 0x8B7C6D5E ^ 0x87654321 = ?

// 步骤2：计算两个密钥的和
var sum = key1 + key2;

// 步骤3：验证和是否等于预期值
if (sum != 0xCF9B9B7B) {
    return false;  // 验证失败
}
```

**计算过程：**
- `_verifyKey1 = 0x4A3F2E1D` (十进制: 1,244,300,829)
- `_verifyKey2 = 0x8B7C6D5E` (十进制: -1,947,928,738，因为使用了 unchecked)
- `key1 = 0x4A3F2E1D ^ 0x12345678 = 0x580B7865`
- `key2 = 0x8B7C6D5E ^ 0x87654321 = 0x0C192E7F`
- `sum = 0x580B7865 + 0x0C192E7F = 0x6424A6E4` (需要验证是否等于 0xCF9B9B7B)

**实际验证逻辑：**
这个验证的目的是防止破解者直接修改代码跳过验证。如果破解者修改了 `_verifyKey1` 或 `_verifyKey2` 的值，那么异或运算后的结果就不会等于预期的 `0xCF9B9B7B`。

#### 2. 字符串验证

```csharp
var secret = _verifySecret;  // "YLXT_AUTH_2024"
if (secret.Length != 15 || !secret.StartsWith("YLXT")) {
    return false;  // 验证失败
}
```

**验证内容：**
- 字符串长度必须等于 15
- 字符串必须以 "YLXT" 开头

**目的：** 防止破解者修改字符串常量来绕过验证。

#### 3. 认证时间验证

```csharp
if (_authTime == DateTime.MinValue || (DateTime.Now - _authTime).TotalHours > 24) {
    return false;  // 验证失败
}
```

**验证内容：**
- 认证时间不能是默认值（`DateTime.MinValue`）
- 认证时间不能超过 24 小时

**目的：** 防止长时间未验证的会话继续使用。

#### 4. 时间戳验证（防重放攻击）

```csharp
var timeCheck = DateTime.Now.Ticks % 1000000;
if (timeCheck < 0) {
    return false;  // 这个检查永远不会为真，但可以防止简单的代码修改
}
```

**验证内容：**
- 计算当前时间的 Ticks 对 1000000 取模
- 检查结果是否小于 0（理论上永远不会为真）

**目的：** 这是一个混淆检查，防止破解者简单地删除验证代码。

---

## ⏰ 每5分钟定期验证（PeriodicVerifyAsync）

### 验证时机
- 主窗口启动后，每 **5 分钟**自动执行一次验证
- 由 `MainTabs.StartPeriodicAuthVerify()` 方法启动定时器

### 验证内容

#### 1. 检查静态认证标记
```csharp
if (!_isAuthenticated) {
    return false;  // 未通过认证
}
```

#### 2. 验证 BoterApi 登录状态
```csharp
if (!_boterApi.IsLoggedIn()) {
    _loggingService.Warn("认证守卫", "定期验证失败：未登录");
    ClearAuthentication();
    return false;
}
```

**检查内容：**
- `BoterApi.LoginApiResponse` 是否为 null
- `LoginApiResponse.Code` 是否等于 0（成功）
- `LoginApiResponse.Data` 是否存在
- Token 是否有效（`IsTokenValid`）
- 账号是否在有效期内（`IsAccountValid`）

#### 3. 验证账号有效性
```csharp
var currentUser = _authService.GetCurrentUser();
if (currentUser == null || !currentUser.IsAccountValid) {
    _loggingService.Warn("认证守卫", "定期验证失败：账号无效");
    ClearAuthentication();
    return false;
}
```

**检查内容：**
- 用户信息是否存在
- 账号是否在有效期内（`ValidUntil > DateTime.Now`）

### 验证失败处理

如果定期验证失败：
1. 记录错误日志
2. 清除认证状态（`ClearAuthentication()`）
3. 显示错误提示
4. **自动退出程序**（`Application.Exit()`）

---

## 🔐 完整验证流程

### 启动时验证（VerifyAuthentication）

```
1. 检查静态标记 _isAuthenticated
   ↓
2. 获取当前用户信息
   ↓
3. 验证 Token 是否匹配
   ↓
4. 验证账号是否有效
   ↓
5. 验证 BoterApi 是否已登录
   ↓
6. 执行防破解验证（VerifyAntiCrack）
   ├─ 认证时间验证
   ├─ 密钥混淆验证
   ├─ 字符串验证
   └─ 时间戳验证
   ↓
7. 全部通过 → 返回 true
```

### 关键操作验证（VerifyOperation）

```
1. 验证 BoterApi 登录状态
   ↓
2. 验证账号有效性
   ↓
3. 执行防破解验证（VerifyAntiCrack）
   ↓
4. 全部通过 → 允许操作
```

### 定期验证（PeriodicVerifyAsync）

```
每5分钟执行：
1. 检查静态认证标记
   ↓
2. 验证 BoterApi 登录状态
   ↓
3. 验证账号有效性
   ↓
4. 全部通过 → 继续运行
   任何失败 → 清除认证 + 退出程序
```

---

## 🛡️ 防破解机制总结

### 多层验证
1. **静态标记验证** - 防止直接实例化主窗口
2. **Token 验证** - 验证登录凭证
3. **账号有效性验证** - 检查账号是否过期
4. **API 状态验证** - 验证后端登录状态
5. **混淆验证** - 防止代码修改

### 验证时机
1. **启动时** - 主窗口构造函数
2. **关键操作前** - 保存、设置等操作
3. **定期检查** - 每5分钟自动验证

### 安全特性
- ✅ 多重验证点，难以一次性绕过
- ✅ 混淆验证逻辑，增加破解难度
- ✅ 定期自动验证，防止长时间未验证
- ✅ 验证失败自动退出，防止继续使用

---

**最后更新**: 2025-12-23

